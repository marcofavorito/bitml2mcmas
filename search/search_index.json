{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BitML2MCMAS","text":"<p>Strategic Reasoning for BitML Smart Contracts using MCMAS.</p>"},{"location":"#installation","title":"Installation","text":"<p>The tool has been tested on Linux (Ubuntu LTS 22.04).</p> <ul> <li> <p>Make sure Python is installed.</p> </li> <li> <p>Download the repository:</p> </li> </ul> <pre><code>git clone git@github.com:marcofavorito/bitml2mcmas.git\n</code></pre> <ul> <li>Install the package:</li> </ul> <pre><code>cd bitml2mcmas\npip install .\n</code></pre> <ul> <li> <p>To process the ISPL file, you need the MCMAS tool, which you can download from the official website: https://sail.doc.ic.ac.uk/software/mcmas/.</p> </li> <li> <p>To run tests with <code>pytest</code>, add the <code>mcmas</code> binary in <code>tests/bin</code>.</p> </li> <li> <p>We use <code>poetry</code> to handle the development dependencies. To install them, do <code>poetry install</code>, and then <code>poetry shell</code>. </p> </li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<ul> <li>Define the BitML contract in the BitML syntax (see the original BitML project):</li> </ul> <pre><code>bitml_timed_commitment = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n    (secret \"A\" a1 \"0001a\")\n  )\n  (choice\n    (reveal (a1) (withdraw \"A\"))\n    (after 1 (withdraw \"B\"))\n  )\n)\n\n\"\"\"\n</code></pre> <ul> <li>Parse the BitML contract:</li> </ul> <pre><code>from bitml2mcmas.bitml.parser.parser import BitMLParser\n\nparser = BitMLParser()\ncontract = parser(bitml_timed_commitment)\n</code></pre> <ul> <li>Compile in an ISPL file. You may specify (1) evaluation rules, that define the alphabet over which formulae are defined, and (2) the ATL formulas to specify:</li> </ul> <pre><code>from pathlib import Path\nfrom bitml2mcmas.compiler.core import Compiler\nfrom bitml2mcmas.mcmas.ast import EvaluationRule\nfrom bitml2mcmas.mcmas.boolcond import EqualTo, EnvironmentIdAtom, IntAtom\nfrom bitml2mcmas.mcmas.formula import AtomicFormula, DiamondEventuallyFormula\nfrom bitml2mcmas.mcmas.to_string import interpreted_system_to_string\n\nformulae = [DiamondEventuallyFormula(\"Agent_A\", AtomicFormula(\"A_gets_1\"))]\nevaluation_rules = [\n    EvaluationRule(\"A_gets_1\",\n                   EqualTo(EnvironmentIdAtom(\"part_A_total_deposits\"),\n                           IntAtom(1)))\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system = compiler.compile()\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\nPath(\"output.ispl\").write_text(interpreted_system_str)\n</code></pre> <ul> <li>Use the <code>mcmas</code> tool to process the <code>output.ispl</code> file.  </li> </ul> <pre><code>mcmas -atlk 1 output.ispl\n</code></pre>"},{"location":"#docs","title":"Docs","text":"<p>To build the docs: <code>mkdocs build</code></p> <p>To view documentation in a browser: <code>mkdocs serve</code> and then go to http://localhost:8000</p>"},{"location":"mutual-timed-commitment-tutorial/","title":"Tutorial: Mutual Timed Commitment Contract","text":"<p>In this tutorial, we will demonstrate the features of our tool using as example the Mutual Timed Commitment Contract. Other examples (escrow contract, zero-coupon bond contract) can be found in the notebook <code>docs/tutorial.ipnyb</code>.</p> <p>Table of contents:</p> <ul> <li>Mutual Timed Commitment<ul> <li>Definition of the BitML contract</li> <li>Programmatic contract definition</li> <li>Definition of the ATL specifications<ul> <li>First specification</li> <li>Second specification</li> <li>Third specification</li> </ul> </li> <li>Translation to ISPL</li> <li>ATL model checking with MCMAS</li> </ul> </li> <li>Flawed Mutual Timed Commitment</li> <li>Additional features<ul> <li>Generation of witnesses/counterexamples</li> <li>Simulation of the ISPL model</li> <li>Visualization of the model</li> </ul> </li> </ul> In\u00a0[1]: Copied! <pre>bitml_mutual_timed_commitment = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n    (deposit \"B\" 1 \"txB@0\")\n    (secret \"A\" a \"0001a\")\n    (secret \"B\" b \"0001b\")\n  )\n  (choice\n    (reveal (a) (choice\n      (reveal (b) (split\n        (1 -&gt; (withdraw \"A\"))\n        (1 -&gt; (withdraw \"B\"))\n      ))\n      (after 2 (withdraw \"A\"))\n    ))\n    (after 1 (withdraw \"B\"))\n  )\n)\n\"\"\"\n</pre> bitml_mutual_timed_commitment = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\")  (contract   (pre     (deposit \"A\" 1 \"txA@0\")     (deposit \"B\" 1 \"txB@0\")     (secret \"A\" a \"0001a\")     (secret \"B\" b \"0001b\")   )   (choice     (reveal (a) (choice       (reveal (b) (split         (1 -&gt; (withdraw \"A\"))         (1 -&gt; (withdraw \"B\"))       ))       (after 2 (withdraw \"A\"))     ))     (after 1 (withdraw \"B\"))   ) ) \"\"\" <p>Now, we will use the class <code>BitMLParser</code> to create an object representation of the BitML smart contract:</p> In\u00a0[2]: Copied! <pre>from bitml2mcmas.bitml.parser.parser import BitMLParser\n\n# parse the contract\nparser = BitMLParser()\ncontract = parser(bitml_mutual_timed_commitment)\n</pre> from bitml2mcmas.bitml.parser.parser import BitMLParser  # parse the contract parser = BitMLParser() contract = parser(bitml_mutual_timed_commitment) <p>We use the Lark parsing toolkit to generate the parser.</p> In\u00a0[3]: Copied! <pre>from decimal import Decimal\n\nfrom bitml2mcmas.bitml.ast import BitMLParticipant, BitMLDepositPrecondition, BitMLTransactionOutput, \\\n    BitMLSecretPrecondition, BitMLChoiceExpression, BitMLRevealExpression, BitMLSplitBranch, BitMLAfterExpression, \\\n    BitMLWithdrawExpression, BitMLSplitExpression\nfrom bitml2mcmas.bitml.core import BitMLContract\n\nparticipant_a = BitMLParticipant(identifier='A', pubkey='0a')\nparticipant_b = BitMLParticipant(identifier='B', pubkey='0b')\ndeposit_a = BitMLDepositPrecondition(\n    participant_id='A',\n    amount=Decimal('1'),\n    tx=BitMLTransactionOutput(tx_identifier='txA', tx_output_index=0)\n)\ndeposit_b = BitMLDepositPrecondition(\n    participant_id='B',\n    amount=Decimal('1'),\n    tx=BitMLTransactionOutput(tx_identifier='txB', tx_output_index=0)\n)\nsecret_a = BitMLSecretPrecondition(participant_id='A', secret_id='a', secret_hash='0001a')\nsecret_b = BitMLSecretPrecondition(participant_id='B', secret_id='b', secret_hash='0001b')\n\n\ncontract_code = BitMLChoiceExpression(choices=[\n    BitMLRevealExpression(\n            secret_ids=['a'],\n            branch=BitMLChoiceExpression(choices=[\n                BitMLRevealExpression(\n                    secret_ids=['b'],\n                    branch=BitMLSplitExpression(branches=[\n                        BitMLSplitBranch(amount=Decimal('1'), branch=BitMLWithdrawExpression(participant_id='A')),\n                        BitMLSplitBranch(amount=Decimal('1'), branch=BitMLWithdrawExpression(participant_id='B'))\n                    ])),\n                BitMLAfterExpression(\n                    timeout=2,\n                    branch=BitMLWithdrawExpression(participant_id='A'))\n            ])),\n    BitMLAfterExpression(timeout=1, branch=BitMLWithdrawExpression(participant_id='B'))\n])\n\n\n_contract = BitMLContract(\n    participants=[\n        participant_a,\n        participant_b\n    ],\n    preconditions=[\n        deposit_a,\n        deposit_b,\n        secret_a,\n        secret_b\n    ],\n    contract=contract_code\n)\n</pre> from decimal import Decimal  from bitml2mcmas.bitml.ast import BitMLParticipant, BitMLDepositPrecondition, BitMLTransactionOutput, \\     BitMLSecretPrecondition, BitMLChoiceExpression, BitMLRevealExpression, BitMLSplitBranch, BitMLAfterExpression, \\     BitMLWithdrawExpression, BitMLSplitExpression from bitml2mcmas.bitml.core import BitMLContract  participant_a = BitMLParticipant(identifier='A', pubkey='0a') participant_b = BitMLParticipant(identifier='B', pubkey='0b') deposit_a = BitMLDepositPrecondition(     participant_id='A',     amount=Decimal('1'),     tx=BitMLTransactionOutput(tx_identifier='txA', tx_output_index=0) ) deposit_b = BitMLDepositPrecondition(     participant_id='B',     amount=Decimal('1'),     tx=BitMLTransactionOutput(tx_identifier='txB', tx_output_index=0) ) secret_a = BitMLSecretPrecondition(participant_id='A', secret_id='a', secret_hash='0001a') secret_b = BitMLSecretPrecondition(participant_id='B', secret_id='b', secret_hash='0001b')   contract_code = BitMLChoiceExpression(choices=[     BitMLRevealExpression(             secret_ids=['a'],             branch=BitMLChoiceExpression(choices=[                 BitMLRevealExpression(                     secret_ids=['b'],                     branch=BitMLSplitExpression(branches=[                         BitMLSplitBranch(amount=Decimal('1'), branch=BitMLWithdrawExpression(participant_id='A')),                         BitMLSplitBranch(amount=Decimal('1'), branch=BitMLWithdrawExpression(participant_id='B'))                     ])),                 BitMLAfterExpression(                     timeout=2,                     branch=BitMLWithdrawExpression(participant_id='A'))             ])),     BitMLAfterExpression(timeout=1, branch=BitMLWithdrawExpression(participant_id='B')) ])   _contract = BitMLContract(     participants=[         participant_a,         participant_b     ],     preconditions=[         deposit_a,         deposit_b,         secret_a,         secret_b     ],     contract=contract_code ) <p>To build this ATL formula in our library, we require the definition of the two propositions:</p> <ul> <li><code>private_secret_a_is_invalid</code>: the secret commitment for <code>a</code> is invalid</li> <li><code>part_A_total_deposits_at_least_1</code>: the total of deposits held by participant $\\texttt{A}$ is at least 1</li> </ul> <p>In BitML2MCMAS, a proposition requires:</p> <ul> <li>an instance of <code>AtomicFormula</code>, used to build more complex formulae;</li> <li>an instance of <code>EvaluationRule</code>, which defines its semantics.</li> </ul> <p>Below, the <code>Environment</code>'s variables <code>private_secret_a</code> and <code>part_A_total_deposits</code> are the names of the state variables generated by our translator:</p> <ul> <li><code>private_secret_a</code>: the private state of the secret <code>a</code>, an enumeration of <code>{not_committed, valid, invalid}</code>;</li> <li><code>part_A_total_deposits</code>: a variable that keeps track of the total deposits held by participant A (an integer).</li> </ul> In\u00a0[4]: Copied! <pre>from bitml2mcmas.mcmas.boolcond import EqualTo, EnvironmentIdAtom, IdAtom, GreaterThanOrEqual, IntAtom\nfrom bitml2mcmas.mcmas.ast import EvaluationRule\nfrom bitml2mcmas.mcmas.formula import AtomicFormula\n\n########################################\n# private_secret_a_is_invalid: the secret commitment for 'a' is invalid\n# Definition: private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid);\n# The corresponding evaluation rule is added by default in the output ISPL program by our translator\n\nPRIVATE_SECRET_A_IS_INVALID_PROP = \"private_secret_a_is_invalid\"\nPRIVATE_SECRET_A_IS_INVALID = AtomicFormula(PRIVATE_SECRET_A_IS_INVALID_PROP)\n########################################\n\n########################################\n# part_A_total_deposits_is_at_least_1: the total of deposits held by participant A is at least 1\n# Definition: part_A_total_deposits_is_at_least_1 if (Environment.part_A_total_deposits &gt;= 1);\n\n# The name of the state variable for keeping track of the total deposits held by participant A, an integer\nVAR_PART_A_TOTAL_DEPOSITS = \"part_A_total_deposits\"\n\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_A_total_deposits_is_at_least_1\"\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP)\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(\n    PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1))\n)\n########################################\n</pre> from bitml2mcmas.mcmas.boolcond import EqualTo, EnvironmentIdAtom, IdAtom, GreaterThanOrEqual, IntAtom from bitml2mcmas.mcmas.ast import EvaluationRule from bitml2mcmas.mcmas.formula import AtomicFormula  ######################################## # private_secret_a_is_invalid: the secret commitment for 'a' is invalid # Definition: private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid); # The corresponding evaluation rule is added by default in the output ISPL program by our translator  PRIVATE_SECRET_A_IS_INVALID_PROP = \"private_secret_a_is_invalid\" PRIVATE_SECRET_A_IS_INVALID = AtomicFormula(PRIVATE_SECRET_A_IS_INVALID_PROP) ########################################  ######################################## # part_A_total_deposits_is_at_least_1: the total of deposits held by participant A is at least 1 # Definition: part_A_total_deposits_is_at_least_1 if (Environment.part_A_total_deposits &gt;= 1);  # The name of the state variable for keeping track of the total deposits held by participant A, an integer VAR_PART_A_TOTAL_DEPOSITS = \"part_A_total_deposits\"  PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_A_total_deposits_is_at_least_1\" PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP) PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(     PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1)) ) ######################################## <p>Now, we can define the target ATL formula:</p> In\u00a0[5]: Copied! <pre>from bitml2mcmas.mcmas.formula import DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula\n\n# AG((private_secret_a_is_invalid) -&gt; (!&lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_1)))\nIF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        PRIVATE_SECRET_A_IS_INVALID,\n        NotFormula(\n            DiamondEventuallyFormula(\"Agent_A\", PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1)\n        )\n    )\n)\n</pre> from bitml2mcmas.mcmas.formula import DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula  # AG((private_secret_a_is_invalid) -&gt; (!F(part_A_total_deposits_is_at_least_1))) IF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         PRIVATE_SECRET_A_IS_INVALID,         NotFormula(             DiamondEventuallyFormula(\"Agent_A\", PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1)         )     ) ) In\u00a0[6]: Copied! <pre>from bitml2mcmas.mcmas.formula import DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula\n\n########################################\n# public_secret_b_is_valid: the secret commitment for 'b' is valid\n# Definition: public_secret_b_is_valid if (Environment.public_secret_b = valid);\n# The corresponding evaluation rule is added by default in the output ISPL program by our translator\n\n# The name of the state variable for the state of the public secret 'b', an enumeration of {not_committed, committed, valid}\nVAR_PUBLIC_SECRET_B = \"public_secret_b\"\n\nPUBLIC_SECRET_B_IS_VALID_PROP = \"public_secret_b_is_valid\"\nPUBLIC_SECRET_B_IS_VALID = AtomicFormula(PUBLIC_SECRET_B_IS_VALID_PROP)\n########################################\n\n########################################\n# timeout_1_has_expired: true iff the first timeout in the contract has expired\n# Definition: timeout_1_has_expired if (Environment.time &gt;= 1);\n# The corresponding evaluation rule is added by default in the output ISPL program by our translator\nTIMEOUT_1_HAS_EXPIRED_PROP = \"timeout_1_has_expired\"\nTIMEOUT_1_HAS_EXPIRED = AtomicFormula(TIMEOUT_1_HAS_EXPIRED_PROP)\n########################################\n\n########################################\n# part_B_total_deposits_is_2: the total of deposits held by participant B is equal to 2\n# Definition: part_B_total_deposits_is_2 if (Environment.part_B_total_deposits = 2);\n\n# The name of the state variable for keeping track of the total deposits held by participant B (an integer)\nVAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\"\n\nPART_B_TOTAL_DEPOSITS_IS_2_PROP = \"part_B_total_deposits_is_2\"\nPART_B_TOTAL_DEPOSITS_IS_2 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_2_PROP)\nPART_B_TOTAL_DEPOSITS_IS_2_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_2_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(2))\n)\n########################################\n</pre> from bitml2mcmas.mcmas.formula import DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula  ######################################## # public_secret_b_is_valid: the secret commitment for 'b' is valid # Definition: public_secret_b_is_valid if (Environment.public_secret_b = valid); # The corresponding evaluation rule is added by default in the output ISPL program by our translator  # The name of the state variable for the state of the public secret 'b', an enumeration of {not_committed, committed, valid} VAR_PUBLIC_SECRET_B = \"public_secret_b\"  PUBLIC_SECRET_B_IS_VALID_PROP = \"public_secret_b_is_valid\" PUBLIC_SECRET_B_IS_VALID = AtomicFormula(PUBLIC_SECRET_B_IS_VALID_PROP) ########################################  ######################################## # timeout_1_has_expired: true iff the first timeout in the contract has expired # Definition: timeout_1_has_expired if (Environment.time &gt;= 1); # The corresponding evaluation rule is added by default in the output ISPL program by our translator TIMEOUT_1_HAS_EXPIRED_PROP = \"timeout_1_has_expired\" TIMEOUT_1_HAS_EXPIRED = AtomicFormula(TIMEOUT_1_HAS_EXPIRED_PROP) ########################################  ######################################## # part_B_total_deposits_is_2: the total of deposits held by participant B is equal to 2 # Definition: part_B_total_deposits_is_2 if (Environment.part_B_total_deposits = 2);  # The name of the state variable for keeping track of the total deposits held by participant B (an integer) VAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\"  PART_B_TOTAL_DEPOSITS_IS_2_PROP = \"part_B_total_deposits_is_2\" PART_B_TOTAL_DEPOSITS_IS_2 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_2_PROP) PART_B_TOTAL_DEPOSITS_IS_2_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_2_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(2)) ) ######################################## <p>Finally, we can define the target ${\\rm ATL}$ formula in code:</p> In\u00a0[7]: Copied! <pre>from bitml2mcmas.mcmas.formula import AndFormula\n\n# AG((!public_secret_b_is_valid and private_secret_a_is_invalid and timeout_1_has_expired)\n#     -&gt; &lt;Agent_B&gt;F(!public_secret_b_is_valid and part_B_total_deposits_is_2))\nIF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        AndFormula(\n            NotFormula(PUBLIC_SECRET_B_IS_VALID),\n            AndFormula(\n                PRIVATE_SECRET_A_IS_INVALID,\n                TIMEOUT_1_HAS_EXPIRED\n            )\n        ),\n        DiamondEventuallyFormula(\"Agent_B\",\n                                 AndFormula(\n                                     NotFormula(PUBLIC_SECRET_B_IS_VALID),\n                                     PART_B_TOTAL_DEPOSITS_IS_2\n                                 )\n        )\n    )\n)\n</pre> from bitml2mcmas.mcmas.formula import AndFormula  # AG((!public_secret_b_is_valid and private_secret_a_is_invalid and timeout_1_has_expired) #     -&gt; F(!public_secret_b_is_valid and part_B_total_deposits_is_2)) IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         AndFormula(             NotFormula(PUBLIC_SECRET_B_IS_VALID),             AndFormula(                 PRIVATE_SECRET_A_IS_INVALID,                 TIMEOUT_1_HAS_EXPIRED             )         ),         DiamondEventuallyFormula(\"Agent_B\",                                  AndFormula(                                      NotFormula(PUBLIC_SECRET_B_IS_VALID),                                      PART_B_TOTAL_DEPOSITS_IS_2                                  )         )     ) )  In\u00a0[8]: Copied! <pre>########################################\n# contract_is_initialized: true iff the contract is initialized or not in the current state\n# Definition: contract_is_initialized if (Environment.contract_initialized = true);\n# The corresponding evaluation rule is added by default in the output ISPL program by our translator\nCONTRACT_IS_INITIALIZED_PROP = \"contract_is_initialized\"\nCONTRACT_IS_INITIALIZED = AtomicFormula(CONTRACT_IS_INITIALIZED_PROP)\n########################################\n\n\n########################################\n# private_secret_b_is_valid: the secret commitment for 'b' is valid\n# Definition: private_secret_b_is_valid if (Agent_B.private_secret_b = valid);\n# The corresponding evaluation rule is added by default in the output ISPL program by our translator\n\n# The state of the private secret 'b', an enumeration of {not_committed, valid, invalid}\nVAR_PRIVATE_SECRET_B = \"private_secret_b\"\n\nPRIVATE_SECRET_B_IS_VALID_PROP = \"private_secret_b_is_valid\"\nPRIVATE_SECRET_B_IS_VALID = AtomicFormula(PRIVATE_SECRET_B_IS_VALID_PROP)\n########################################\n\n\n########################################\n# part_B_total_deposits_is_at_least_1: the total of deposits held by participant B is at least 1\n# Definition: part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1);\n\n# The name of the state variable for keeping track of the total deposits held by participant B, an integer\nVAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\"\n\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_B_total_deposits_is_at_least_1\"\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP)\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1))\n)\n########################################\n</pre> ######################################## # contract_is_initialized: true iff the contract is initialized or not in the current state # Definition: contract_is_initialized if (Environment.contract_initialized = true); # The corresponding evaluation rule is added by default in the output ISPL program by our translator CONTRACT_IS_INITIALIZED_PROP = \"contract_is_initialized\" CONTRACT_IS_INITIALIZED = AtomicFormula(CONTRACT_IS_INITIALIZED_PROP) ########################################   ######################################## # private_secret_b_is_valid: the secret commitment for 'b' is valid # Definition: private_secret_b_is_valid if (Agent_B.private_secret_b = valid); # The corresponding evaluation rule is added by default in the output ISPL program by our translator  # The state of the private secret 'b', an enumeration of {not_committed, valid, invalid} VAR_PRIVATE_SECRET_B = \"private_secret_b\"  PRIVATE_SECRET_B_IS_VALID_PROP = \"private_secret_b_is_valid\" PRIVATE_SECRET_B_IS_VALID = AtomicFormula(PRIVATE_SECRET_B_IS_VALID_PROP) ########################################   ######################################## # part_B_total_deposits_is_at_least_1: the total of deposits held by participant B is at least 1 # Definition: part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1);  # The name of the state variable for keeping track of the total deposits held by participant B, an integer VAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\"  PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_B_total_deposits_is_at_least_1\" PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP) PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1)) ) ########################################  <p>The ${\\rm ATL}$ formula in code is:</p> In\u00a0[9]: Copied! <pre># AG((contract_is_initialized and private_secret_b_is_valid and !timeout_1_has_expired)\n#    -&gt; (&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_1)))\nIF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        AndFormula(\n            CONTRACT_IS_INITIALIZED,\n            AndFormula(\n                PRIVATE_SECRET_B_IS_VALID,\n                NotFormula(TIMEOUT_1_HAS_EXPIRED)\n            )\n        ),\n        DiamondEventuallyFormula(\"Agent_B\", PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1),\n    )\n)\n</pre> # AG((contract_is_initialized and private_secret_b_is_valid and !timeout_1_has_expired) #    -&gt; (F(part_B_total_deposits_is_at_least_1))) IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         AndFormula(             CONTRACT_IS_INITIALIZED,             AndFormula(                 PRIVATE_SECRET_B_IS_VALID,                 NotFormula(TIMEOUT_1_HAS_EXPIRED)             )         ),         DiamondEventuallyFormula(\"Agent_B\", PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1),     ) ) In\u00a0[10]: Copied! <pre>from bitml2mcmas.compiler.core import Compiler\n\nformulae = [\n    IF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS,\n    IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS,\n    IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS\n]\nevaluation_rules = [\n    PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER,\n    PART_B_TOTAL_DEPOSITS_IS_2_ER,\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER,\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\n</pre> from bitml2mcmas.compiler.core import Compiler  formulae = [     IF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS,     IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS,     IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS ] evaluation_rules = [     PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER,     PART_B_TOTAL_DEPOSITS_IS_2_ER,     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER, ] compiler = Compiler(     contract, formulae, evaluation_rules=evaluation_rules ) <p>Next, we can call the <code>Compiler.compile()</code> function:</p> In\u00a0[11]: Copied! <pre>from pathlib import Path\n\ninterpreted_system = compiler.compile()\n</pre> from pathlib import Path  interpreted_system = compiler.compile() <p>The result is an instance of the <code>InterpretedSystem</code> class, which represents an ISPL program as a Python object.</p> <p>We can inspect the content of the model by accessing its attributes, e.g.:</p> In\u00a0[12]: Copied! <pre>interpreted_system.agents\ninterpreted_system.environment\ninterpreted_system.evaluation_rules\ninterpreted_system.initial_states_boolean_condition\ninterpreted_system.groups\ninterpreted_system.fair_formulae\ninterpreted_system.formulae;\n</pre> interpreted_system.agents interpreted_system.environment interpreted_system.evaluation_rules interpreted_system.initial_states_boolean_condition interpreted_system.groups interpreted_system.fair_formulae interpreted_system.formulae; <p>The definitions of all other classes and functions for ISPL can be found in the <code>bitml2mcmas.mcmas</code> subpackage.</p> <p>From the <code>InterpretedSystem</code> object, we can generate an ISPL file with the function <code>interpreted_system_to_string</code></p> In\u00a0[13]: Copied! <pre>from bitml2mcmas.mcmas.to_string import interpreted_system_to_string\n\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\n_ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model.ispl\").write_text(interpreted_system_str)\n</pre> from bitml2mcmas.mcmas.to_string import interpreted_system_to_string  interpreted_system_str = interpreted_system_to_string(interpreted_system) _ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model.ispl\").write_text(interpreted_system_str) <p>The output file <code>model.ispl</code> is pasted below:</p> <pre><code>Semantics=SingleAssignment;\nAgent Environment\n  Obsvars:\n    time: 0..2;\n    contract_funds: 0..2;\n    part_A_total_deposits: 0..2;\n    part_B_total_deposits: 0..2;\n    public_secret_b: {committed, not_committed, valid};\n    public_secret_a: {committed, not_committed, valid};\n    contract_initialized: boolean;\n    status_node_0_withdraw: {disabled, enabled, executed};\n    status_node_1_withdraw: {disabled, enabled, executed};\n    status_node_2_split: {disabled, enabled, executed};\n    status_node_3_reveal: {disabled, enabled, executed};\n    status_node_4_withdraw: {disabled, enabled, executed};\n    status_node_6_reveal: {disabled, enabled, executed};\n    status_node_7_withdraw: {disabled, enabled, executed};\n  end Obsvars\n  Vars:\n    part_A_is_done: boolean;\n    part_B_is_done: boolean;\n    last_action: {action_delay, action_schedule_part_A, action_schedule_part_B, unset};\n  end Vars\n\n  Actions = {delay, schedule_part_A, schedule_part_B};\n  Protocol:\n    (part_A_is_done = false): {schedule_part_A};\n    (part_B_is_done = false): {schedule_part_B};\n    Other: {delay};\n  end Protocol\n  Evolution:\n    part_A_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_B_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_A_is_done = true if (((Action = schedule_part_A) and (Agent_A.Action = nop)) and (part_A_is_done = false));\n    part_B_is_done = true if (((Action = schedule_part_B) and (Agent_B.Action = nop)) and (part_B_is_done = false));\n    time = (time + 1) if (((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true))) and (time &lt; 2));\n    public_secret_b = committed if (((public_secret_b = not_committed) and ((Agent_B.Action = commit_valid_secret_b) or (Agent_B.Action = commit_invalid_secret_b))) and (Action = schedule_part_B));\n    public_secret_b = valid if (((Agent_B.Action = reveal_secret_b) and (Action = schedule_part_B)) and (public_secret_b = committed));\n    public_secret_a = committed if (((public_secret_a = not_committed) and ((Agent_A.Action = commit_valid_secret_a) or (Agent_A.Action = commit_invalid_secret_a))) and (Action = schedule_part_A));\n    public_secret_a = valid if (((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)) and (public_secret_a = committed));\n    contract_initialized = true if (((contract_initialized = false) and (((public_secret_b = committed) or (public_secret_b = valid)) and ((public_secret_a = committed) or (public_secret_a = valid)))) and (((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    status_node_0_withdraw = executed if (((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)));\n    status_node_0_withdraw = enabled if (((status_node_2_split = executed) or (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)))) and (status_node_0_withdraw = disabled));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    status_node_1_withdraw = executed if (((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)));\n    status_node_1_withdraw = enabled if (((status_node_2_split = executed) or (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)))) and (status_node_1_withdraw = disabled));\n    status_node_2_split = executed if (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)));\n    status_node_2_split = enabled if (((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B)))) and (status_node_2_split = disabled));\n    status_node_3_reveal = executed if (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B)));\n    status_node_3_reveal = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_3_reveal = disabled)) and ((public_secret_b = valid) or ((Agent_B.Action = reveal_secret_b) and (Action = schedule_part_B)))) and (!((status_node_4_withdraw = executed) or (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))))));\n    status_node_3_reveal = disabled if ((status_node_4_withdraw = executed) or (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    status_node_4_withdraw = executed if (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B)));\n    status_node_4_withdraw = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_4_withdraw = disabled)) and ((time &gt;= 2) or ((time = 1) and (Action = delay)))) and (!((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))))));\n    status_node_4_withdraw = disabled if ((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))));\n    status_node_6_reveal = executed if (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)));\n    status_node_6_reveal = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_6_reveal = disabled)) and ((public_secret_a = valid) or ((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)))) and (!((status_node_7_withdraw = executed) or (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B))))));\n    status_node_6_reveal = disabled if ((status_node_7_withdraw = executed) or (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    status_node_7_withdraw = executed if (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B)));\n    status_node_7_withdraw = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_7_withdraw = disabled)) and ((time &gt;= 1) or ((time = 0) and (Action = delay)))) and (!((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B))))));\n    status_node_7_withdraw = disabled if ((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B))));\n    last_action = action_schedule_part_B if (Action = schedule_part_B);\n    last_action = action_schedule_part_A if (Action = schedule_part_A);\n    last_action = action_delay if (Action = delay);\n  end Evolution\nend Agent\n\nAgent Agent_A\n  Lobsvars = {part_A_is_done};\n  Vars:\n    private_secret_a: {invalid, not_committed, valid};\n  end Vars\n\n  Actions = {commit_invalid_secret_a, commit_valid_secret_a, exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_split, exec_node_3_reveal, exec_node_4_withdraw, exec_node_6_reveal, exec_node_7_withdraw, initialize_contract, nop, reveal_secret_a};\n  Protocol:\n    (((Environment.contract_initialized = false) and (private_secret_a = not_committed)) and (Environment.part_A_is_done = false)): {commit_invalid_secret_a, commit_valid_secret_a, nop};\n    (((private_secret_a = valid) and (Environment.public_secret_a = committed)) and (Environment.part_A_is_done = false)): {nop, reveal_secret_a};\n    (((Environment.contract_initialized = false) and (Environment.part_A_is_done = false)) and (((Environment.public_secret_b = committed) or (Environment.public_secret_b = valid)) and ((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid)))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_split = enabled) and (Environment.part_A_is_done = false)): {exec_node_2_split, nop};\n    ((Environment.status_node_3_reveal = enabled) and (Environment.part_A_is_done = false)): {exec_node_3_reveal, nop};\n    ((Environment.status_node_4_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_4_withdraw, nop};\n    ((Environment.status_node_6_reveal = enabled) and (Environment.part_A_is_done = false)): {exec_node_6_reveal, nop};\n    ((Environment.status_node_7_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_7_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    private_secret_a = valid if ((((Action = commit_valid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n    private_secret_a = invalid if ((((Action = commit_invalid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n  end Evolution\nend Agent\nAgent Agent_B\n  Lobsvars = {part_B_is_done};\n  Vars:\n    private_secret_b: {invalid, not_committed, valid};\n  end Vars\n\n  Actions = {commit_invalid_secret_b, commit_valid_secret_b, exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_split, exec_node_3_reveal, exec_node_4_withdraw, exec_node_6_reveal, exec_node_7_withdraw, initialize_contract, nop, reveal_secret_b};\n  Protocol:\n    (((Environment.contract_initialized = false) and (private_secret_b = not_committed)) and (Environment.part_B_is_done = false)): {commit_invalid_secret_b, commit_valid_secret_b, nop};\n    (((private_secret_b = valid) and (Environment.public_secret_b = committed)) and (Environment.part_B_is_done = false)): {nop, reveal_secret_b};\n    (((Environment.contract_initialized = false) and (Environment.part_B_is_done = false)) and (((Environment.public_secret_b = committed) or (Environment.public_secret_b = valid)) and ((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid)))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_split = enabled) and (Environment.part_B_is_done = false)): {exec_node_2_split, nop};\n    ((Environment.status_node_3_reveal = enabled) and (Environment.part_B_is_done = false)): {exec_node_3_reveal, nop};\n    ((Environment.status_node_4_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_4_withdraw, nop};\n    ((Environment.status_node_6_reveal = enabled) and (Environment.part_B_is_done = false)): {exec_node_6_reveal, nop};\n    ((Environment.status_node_7_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_7_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    private_secret_b = valid if ((((Action = commit_valid_secret_b) and (private_secret_b = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_B));\n    private_secret_b = invalid if ((((Action = commit_invalid_secret_b) and (private_secret_b = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_B));\n  end Evolution\nend Agent\nEvaluation\n  part_A_is_scheduled if (Environment.last_action = action_schedule_part_A);\n  part_B_is_scheduled if (Environment.last_action = action_schedule_part_B);\n  time_progresses_forever if ((Environment.time = 2) or (Environment.last_action = action_delay));\n  time_reaches_maximum if (Environment.time = 2);\n  timeout_1_has_expired if (Environment.time &gt;= 1);\n  timeout_2_has_expired if (Environment.time &gt;= 2);\n  part_A_is_done if (Environment.part_A_is_done = true);\n  part_B_is_done if (Environment.part_B_is_done = true);\n  private_secret_b_is_valid if (Agent_B.private_secret_b = valid);\n  private_secret_b_is_invalid if (Agent_B.private_secret_b = invalid);\n  private_secret_b_is_not_committed if (Agent_B.private_secret_b = not_committed);\n  public_secret_b_is_committed if (Environment.public_secret_b = committed);\n  public_secret_b_is_not_committed if (Environment.public_secret_b = not_committed);\n  public_secret_b_is_valid if (Environment.public_secret_b = valid);\n  private_secret_a_is_valid if (Agent_A.private_secret_a = valid);\n  private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid);\n  private_secret_a_is_not_committed if (Agent_A.private_secret_a = not_committed);\n  public_secret_a_is_committed if (Environment.public_secret_a = committed);\n  public_secret_a_is_not_committed if (Environment.public_secret_a = not_committed);\n  public_secret_a_is_valid if (Environment.public_secret_a = valid);\n  contract_is_initialized if (Environment.contract_initialized = true);\n  node_0_withdraw_is_disabled if (Environment.status_node_0_withdraw = disabled);\n  node_0_withdraw_is_enabled if (Environment.status_node_0_withdraw = enabled);\n  node_0_withdraw_is_executed if (Environment.status_node_0_withdraw = executed);\n  node_1_withdraw_is_disabled if (Environment.status_node_1_withdraw = disabled);\n  node_1_withdraw_is_enabled if (Environment.status_node_1_withdraw = enabled);\n  node_1_withdraw_is_executed if (Environment.status_node_1_withdraw = executed);\n  node_2_split_is_disabled if (Environment.status_node_2_split = disabled);\n  node_2_split_is_enabled if (Environment.status_node_2_split = enabled);\n  node_2_split_is_executed if (Environment.status_node_2_split = executed);\n  node_3_reveal_is_disabled if (Environment.status_node_3_reveal = disabled);\n  node_3_reveal_is_enabled if (Environment.status_node_3_reveal = enabled);\n  node_3_reveal_is_executed if (Environment.status_node_3_reveal = executed);\n  node_4_withdraw_is_disabled if (Environment.status_node_4_withdraw = disabled);\n  node_4_withdraw_is_enabled if (Environment.status_node_4_withdraw = enabled);\n  node_4_withdraw_is_executed if (Environment.status_node_4_withdraw = executed);\n  node_6_reveal_is_disabled if (Environment.status_node_6_reveal = disabled);\n  node_6_reveal_is_enabled if (Environment.status_node_6_reveal = enabled);\n  node_6_reveal_is_executed if (Environment.status_node_6_reveal = executed);\n  node_7_withdraw_is_disabled if (Environment.status_node_7_withdraw = disabled);\n  node_7_withdraw_is_enabled if (Environment.status_node_7_withdraw = enabled);\n  node_7_withdraw_is_executed if (Environment.status_node_7_withdraw = executed);\n  part_A_total_deposits_is_at_least_1 if (Environment.part_A_total_deposits &gt;= 1);\n  part_B_total_deposits_is_2 if (Environment.part_B_total_deposits &gt;= 2);\n  part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1);\nend Evaluation\nInitStates\n  (((((((((((((((((((Environment.time = 0) and (Environment.part_A_is_done = false)) and (Environment.part_B_is_done = false)) and (Environment.contract_funds = 2)) and (Environment.part_A_total_deposits = 0)) and (Environment.part_B_total_deposits = 0)) and (Environment.public_secret_b = not_committed)) and (Environment.public_secret_a = not_committed)) and (Agent_B.private_secret_b = not_committed)) and (Agent_A.private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.status_node_0_withdraw = disabled)) and (Environment.status_node_1_withdraw = disabled)) and (Environment.status_node_2_split = disabled)) and (Environment.status_node_3_reveal = disabled)) and (Environment.status_node_4_withdraw = disabled)) and (Environment.status_node_6_reveal = disabled)) and (Environment.status_node_7_withdraw = disabled)) and (Environment.last_action = unset));\nend InitStates\nGroups\n  Participants = {Agent_A, Agent_B};\n  Env = {Environment};\n  ParticipantsAndEnv = {Agent_A, Agent_B, Environment};\n  Agent_B = {Agent_B};\n  Agent_A = {Agent_A};\nend Groups\nFairness\n  part_A_is_scheduled;\n  part_B_is_scheduled;\n  time_progresses_forever;\nend Fairness\nFormulae\n  (AG ((private_secret_a_is_invalid) -&gt; ((!(&lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_1))))));\n  (AG ((((!public_secret_b_is_valid) and (private_secret_a_is_invalid and timeout_1_has_expired))) -&gt; ((&lt;Agent_B&gt;F(((!public_secret_b_is_valid) and part_B_total_deposits_is_2))))));\n  (AG (((contract_is_initialized and (private_secret_b_is_valid and (!timeout_1_has_expired)))) -&gt; ((&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_1)))));\nend Formulae\n</code></pre> <p>We can run our verification task with the MCMAS model checker. By calling MCMAS with the command:</p> <pre><code>./mcmas -atlk 1  docs/mutual-timed-commitment-tutorial-assets/model.ispl\n</code></pre> <p>We get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0 \n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law. \n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./mcmas -atlk 1 docs/model.ispl\n\ndocs/model.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (AG (private_secret_a_is_invalid -&gt; (! (&lt;Agent_A&gt;F part_A_total_deposits_is_at_least_1)))), is TRUE in the model\n  Formula number 2: (AG (((! public_secret_b_is_valid) &amp;&amp; (private_secret_a_is_invalid &amp;&amp; timeout_1_has_expired)) -&gt; (&lt;Agent_B&gt;F ((! public_secret_b_is_valid) &amp;&amp; part_B_total_deposits_is_2)))), is TRUE in the model\n  Formula number 3: (AG ((contract_is_initialized &amp;&amp; (private_secret_b_is_valid &amp;&amp; (! timeout_1_has_expired))) -&gt; (&lt;Agent_B&gt;F part_B_total_deposits_is_at_least_1))), is TRUE in the model\ndone, 3 formulae successfully read and checked\nexecution time = 1.808\nnumber of reachable states = 1659\nBDD memory in use = 14733968\n</code></pre> In\u00a0[14]: Copied! <pre>bitml_mutual_timed_commitment_flawed = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n    (deposit \"B\" 1 \"txB@0\")\n    (secret \"A\" a \"0001a\")\n    (secret \"B\" b \"0001b\")\n  )\n  (choice\n    (reveal (a) (choice\n      (reveal (b) (split\n        (1 -&gt; (withdraw \"A\"))\n        (1 -&gt; (withdraw \"B\"))\n      ))\n      (after 1 (withdraw \"A\"))\n    ))\n    (after 1 (withdraw \"B\"))\n  )\n)\n\"\"\"\ncontract_flawed = parser(bitml_mutual_timed_commitment_flawed)\ncompiler_2 = Compiler(\n    contract_flawed, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system_2 = compiler_2.compile()\ninterpreted_system_2_str = interpreted_system_to_string(interpreted_system_2)\n_ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_flawed.ispl\").write_text(interpreted_system_2_str)\n</pre> bitml_mutual_timed_commitment_flawed = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\")  (contract   (pre     (deposit \"A\" 1 \"txA@0\")     (deposit \"B\" 1 \"txB@0\")     (secret \"A\" a \"0001a\")     (secret \"B\" b \"0001b\")   )   (choice     (reveal (a) (choice       (reveal (b) (split         (1 -&gt; (withdraw \"A\"))         (1 -&gt; (withdraw \"B\"))       ))       (after 1 (withdraw \"A\"))     ))     (after 1 (withdraw \"B\"))   ) ) \"\"\" contract_flawed = parser(bitml_mutual_timed_commitment_flawed) compiler_2 = Compiler(     contract_flawed, formulae, evaluation_rules=evaluation_rules ) interpreted_system_2 = compiler_2.compile() interpreted_system_2_str = interpreted_system_to_string(interpreted_system_2) _ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_flawed.ispl\").write_text(interpreted_system_2_str) <p>By repeating the translation and the verification:</p> <pre><code>./mcmas -atlk 1 docs/mutual-timed-commitment-tutorial-assets/model_flawed.ispl\n</code></pre> <p>we get the following result:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0\n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law.\n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./mcmas -atlk 1 -c 3 docs/mutual-timed-commitment-tutorial-assets/model_flawed.ispl\n\ndocs/mutual-timed-commitment-tutorial-assets/model_flawed.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (AG (private_secret_a_is_invalid -&gt; (! (&lt;Agent_A&gt;F part_A_total_deposits_is_at_least_1)))), is TRUE in the model\n    -- Sorry it is not possible to compute witnesses for non-ECTLK formulae\n  Formula number 2: (AG (((! public_secret_b_is_valid) &amp;&amp; (private_secret_a_is_invalid &amp;&amp; timeout_1_has_expired)) -&gt; (&lt;Agent_B&gt;F ((! public_secret_b_is_valid) &amp;&amp; part_B_total_deposits_is_2)))), is TRUE in the model\n    -- Sorry it is not possible to compute witnesses for non-ECTLK formulae\n  Formula number 3: (AG ((contract_is_initialized &amp;&amp; (private_secret_b_is_valid &amp;&amp; (! timeout_1_has_expired))) -&gt; (&lt;Agent_B&gt;F part_B_total_deposits_is_at_least_1))), is FALSE in the model\n  The following is a counterexample for the formula:\n OPERATOR CURRENTLY NOT SUPPORTED IN WITNESS/COUNTEREXAMPLEA counterexample exists but could not be generated.\ndone, 3 formulae successfully read and checked\nexecution time = 2.096\nnumber of reachable states = 791\nBDD memory in use = 15016176\n</code></pre> <p>In particular, note that now formula number 3 is not satisfied.</p> <p>Here is the <code>diff</code> between <code>model.ispl</code> and <code>model_flawed.ispl</code>:</p> <pre><code>diff docs/mutual-timed-commitment-tutorial-assets/model.ispl docs/mutual-timed-commitment-tutorial-assets/model_flawed.ispl\n</code></pre> <pre><code>4c4\n&lt;     time: 0..2;\n---\n&gt;     time: 0..1;\n36c36\n&lt;     time = (time + 1) if (((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true))) and (time &lt; 2));\n---\n&gt;     time = (time + 1) if (((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true))) and (time &lt; 1));\n58c58\n&lt;     status_node_4_withdraw = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_4_withdraw = disabled)) and ((time &gt;= 2) or ((time = 1) and (Action = delay)))) and (!((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))))));\n---\n&gt;     status_node_4_withdraw = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_4_withdraw = disabled)) and ((time &gt;= 1) or ((time = 0) and (Action = delay)))) and (!((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))))));\n127,128c127,128\n&lt;   time_progresses_forever if ((Environment.time = 2) or (Environment.last_action = action_delay));\n&lt;   time_reaches_maximum if (Environment.time = 2);\n---\n&gt;   time_progresses_forever if ((Environment.time = 1) or (Environment.last_action = action_delay));\n&gt;   time_reaches_maximum if (Environment.time = 1);\n130d129\n&lt;   timeout_2_has_expired if (Environment.time &gt;= 2);\n</code></pre> In\u00a0[15]: Copied! <pre>from bitml2mcmas.mcmas.formula import EFFormula, AFFormula\n\n########################################\n# contract_funds_are_zero: true iff there are no more funds deposited in the contracts\n# Definition: contract_funds_are_zero if (Environment.contract_funds = 0);\n\n# The name of the state variable that keeps track of the funds currently held by the contract (an integer)\nVAR_CONTRACT_FUNDS = \"contract_funds\"\n\nCONTRACT_FUNDS_ARE_ZERO_PROP = \"contract_funds_are_zero\"\nCONTRACT_FUNDS_ARE_ZERO = AtomicFormula(CONTRACT_FUNDS_ARE_ZERO_PROP)\nCONTRACT_FUNDS_ARE_ZERO_ER = EvaluationRule(\n    CONTRACT_FUNDS_ARE_ZERO_PROP, \n    EqualTo(EnvironmentIdAtom(VAR_CONTRACT_FUNDS), IntAtom(0))\n)\n########################################\n\n# EF(contract_funds_are_zero)\nEF_CONTRACT_FUNDS_ARE_ZERO = EFFormula(CONTRACT_FUNDS_ARE_ZERO)\n\n# AF(contract_funds_are_zero)\nAF_CONTRACT_FUNDS_ARE_ZERO = AFFormula(CONTRACT_FUNDS_ARE_ZERO)\n\ncompiler_3 = Compiler(\n    contract, \n    [EF_CONTRACT_FUNDS_ARE_ZERO, AF_CONTRACT_FUNDS_ARE_ZERO], \n    evaluation_rules=[CONTRACT_FUNDS_ARE_ZERO_ER]\n)\ninterpreted_system_3 = compiler_3.compile()\ninterpreted_system_3_str = interpreted_system_to_string(interpreted_system_3)\n_ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_witness_counterexample.ispl\").write_text(interpreted_system_3_str)\n</pre> from bitml2mcmas.mcmas.formula import EFFormula, AFFormula  ######################################## # contract_funds_are_zero: true iff there are no more funds deposited in the contracts # Definition: contract_funds_are_zero if (Environment.contract_funds = 0);  # The name of the state variable that keeps track of the funds currently held by the contract (an integer) VAR_CONTRACT_FUNDS = \"contract_funds\"  CONTRACT_FUNDS_ARE_ZERO_PROP = \"contract_funds_are_zero\" CONTRACT_FUNDS_ARE_ZERO = AtomicFormula(CONTRACT_FUNDS_ARE_ZERO_PROP) CONTRACT_FUNDS_ARE_ZERO_ER = EvaluationRule(     CONTRACT_FUNDS_ARE_ZERO_PROP,      EqualTo(EnvironmentIdAtom(VAR_CONTRACT_FUNDS), IntAtom(0)) ) ########################################  # EF(contract_funds_are_zero) EF_CONTRACT_FUNDS_ARE_ZERO = EFFormula(CONTRACT_FUNDS_ARE_ZERO)  # AF(contract_funds_are_zero) AF_CONTRACT_FUNDS_ARE_ZERO = AFFormula(CONTRACT_FUNDS_ARE_ZERO)  compiler_3 = Compiler(     contract,      [EF_CONTRACT_FUNDS_ARE_ZERO, AF_CONTRACT_FUNDS_ARE_ZERO],      evaluation_rules=[CONTRACT_FUNDS_ARE_ZERO_ER] ) interpreted_system_3 = compiler_3.compile() interpreted_system_3_str = interpreted_system_to_string(interpreted_system_3) _ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_witness_counterexample.ispl\").write_text(interpreted_system_3_str) <p>By repeating the translation and the verification with the options to generate witnesses and counterexamples:</p> <pre><code>./mcmas -p docs/mutual-timed-commitment-tutorial-assets/ -atlk 1 -c 3 docs/mutual-timed-commitment-tutorial-assets/model_witness_counterexample.ispl\n</code></pre> <p>we get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0\n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law.\n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./mcmas -p docs/mutual-timed-commitment-tutorial-assets/ -atlk 1 -c 3 docs/mutual-timed-commitment-tutorial-assets/model_witness_counterexample.ispl\n\ndocs/mutual-timed-commitment-tutorial-assets/model_witness_counterexample.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (EF contract_funds_are_zero), is TRUE in the model\n  The following is a witness for the formula:\n   &lt; 0 1 2 3 4 5 6 7 &gt;\n  States description:\n------------- State: 0 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = unset\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 1 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 2 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_A\n  part_A_is_done = true\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 3 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_delay\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 4 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_schedule_part_A\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = invalid\n----------------------------------------\n------------- State: 5 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = invalid\nAgent Agent_A\n  private_secret_a = invalid\n----------------------------------------\n------------- State: 6 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = true\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = enabled\n  time = 1\n  last_action = action_schedule_part_A\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = invalid\nAgent Agent_A\n  private_secret_a = invalid\n----------------------------------------\n------------- State: 7 -----------------\nAgent Environment\n  contract_funds = 0\n  contract_initialized = true\n  part_A_total_deposits = 0\n  part_B_total_deposits = 2\n  public_secret_a = committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = executed\n  time = 1\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = invalid\nAgent Agent_A\n  private_secret_a = invalid\n----------------------------------------\n  Formula number 2: (AF contract_funds_are_zero), is FALSE in the model\n  The following is a counterexample for the formula:\n   &lt; 0 1 2 3 4 5 6 7 8 9 7 &gt;\n  States description:\n------------- State: 0 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = unset\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 1 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 2 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_A\n  part_A_is_done = true\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 3 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_delay\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 4 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = not_committed\n----------------------------------------\n------------- State: 5 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_schedule_part_A\n  part_A_is_done = false\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = valid\n----------------------------------------\n------------- State: 6 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 1\n  last_action = action_schedule_part_A\n  part_A_is_done = true\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = valid\n----------------------------------------\n------------- State: 7 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 2\n  last_action = action_delay\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = valid\n----------------------------------------\n------------- State: 8 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 2\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = valid\n----------------------------------------\n------------- State: 9 -----------------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 2\n  last_action = action_schedule_part_A\n  part_A_is_done = true\n  part_B_is_done = true\nAgent Agent_B\n  private_secret_b = not_committed\nAgent Agent_A\n  private_secret_a = valid\n----------------------------------------\ndone, 2 formulae successfully read and checked\nexecution time = 0.588\nnumber of reachable states = 1659\nBDD memory in use = 12526128\n</code></pre> <p>As expected, we have that <code>EF(contract_funds_are_zero)</code> is true, while <code>AF(contract_funds_are_zero)</code> is false. The MCMAS tool shows the sequence of states that make the formula to be satisfied (in the case of witnesses) or violated (in the case of counterexamples).</p> <p>We can also visualize the witness by rendering the DOT file (the images are reported below):</p> <pre><code>dot -Tsvg docs/mutual-timed-commitment-tutorial-assets/formula1.dot -o docs/mutual-timed-commitment-tutorial-assets/formula1.svg\ndot -Tsvg docs/mutual-timed-commitment-tutorial-assets/formula2.dot -o docs/mutual-timed-commitment-tutorial-assets/formula2.svg\n</code></pre> <p>The following is the visualization of the witness for the formula <code>EF(contract_funds_are_zero)</code>: in this witness, we have a sequence of actions of the three agents of the model, the <code>Environment</code>, <code>Agent_A</code> and <code>Agent_B</code>, which coordinate to make sure the funds in the contract are withdrawn. In particular, (1) first, the time is increased by one, so to make the first timeout to expire; (2) second, the contract is initialized; (3) third, the funds are withdrawn since timeout 1 has expired.</p> <p>The following is the visualization of the counterexample for the formula <code>AF(contract_funds_are_zero)</code>: in this counterexample, the three agents coordinate so to never initialize the contract and withdraw funds, but only by executing \"nop\" actions, while satisfying our fairness constraints (all agents scheduled infinitely often, and time progressed infinitely often):</p> In\u00a0[16]: Copied! <pre>bitml_simple_contract = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n  )\n  (withdraw \"B\")\n)\n\"\"\"\ncontract_simple = parser(bitml_simple_contract)\ncompiler_simple = Compiler(\n    contract_simple, [EF_CONTRACT_FUNDS_ARE_ZERO], evaluation_rules=[CONTRACT_FUNDS_ARE_ZERO_ER]\n)\ninterpreted_system_simple = compiler_simple.compile()\ninterpreted_system_simple_str = interpreted_system_to_string(interpreted_system_simple)\n_ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_simple.ispl\").write_text(interpreted_system_simple_str)\n</pre> bitml_simple_contract = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\")  (contract   (pre     (deposit \"A\" 1 \"txA@0\")   )   (withdraw \"B\") ) \"\"\" contract_simple = parser(bitml_simple_contract) compiler_simple = Compiler(     contract_simple, [EF_CONTRACT_FUNDS_ARE_ZERO], evaluation_rules=[CONTRACT_FUNDS_ARE_ZERO_ER] ) interpreted_system_simple = compiler_simple.compile() interpreted_system_simple_str = interpreted_system_to_string(interpreted_system_simple) _ = Path(\"mutual-timed-commitment-tutorial-assets\", \"model_simple.ispl\").write_text(interpreted_system_simple_str) <p>To export the model, we can run:</p> <pre><code>./mcmas -exportmodel docs/mutual-timed-commitment-tutorial-assets/model_simple.ispl \n</code></pre> <p>and then render the generated DOT file:</p> <pre><code>dot -Tsvg docs/mutual-timed-commitment-tutorial-assets/model.dot -o docs/mutual-timed-commitment-tutorial-assets/model_simpl\ne.svg\n</code></pre> <p>Result:</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"mutual-timed-commitment-tutorial/#tutorial-mutual-timed-commitment-contract","title":"Tutorial: Mutual Timed Commitment Contract\u00b6","text":""},{"location":"mutual-timed-commitment-tutorial/#mutual-timed-commitment","title":"Mutual Timed Commitment\u00b6","text":"<p>In the following, we will verify a BitML formalization of the mutual timed commitment protocol.</p>"},{"location":"mutual-timed-commitment-tutorial/#definition-of-the-bitml-contract","title":"Definition of the BitML contract\u00b6","text":"<p>First, we specify the contract in the BitML DSL. We reimplemented the parsing of the original BitML toolchain in the Lark parsing toolkit. The Lark parser specification can be found at this link.</p>"},{"location":"mutual-timed-commitment-tutorial/#programmatic-contract-definition","title":"Programmatic contract definition\u00b6","text":"<p>Moreover, we can also programmatically define the same BitML smart contract, using the library APIs, as shown below.</p> <p>The code for handling BitML is in the <code>bitml2mcmas.bitml</code> subpackage.</p>"},{"location":"mutual-timed-commitment-tutorial/#definition-of-the-atl-specifications","title":"Definition of the ATL specifications\u00b6","text":"<p>Next, we will declare the ${\\rm ATL}$ specifications we aim to verify.</p>"},{"location":"mutual-timed-commitment-tutorial/#first-specification","title":"First specification\u00b6","text":"<p>We start with the following:</p> <ul> <li>If participant $\\texttt{A}$ publishes an invalid commitment, then he cannot recover his funds:</li> </ul> <p>$$ AG((\\mathsf{private\\_secret\\_a\\_is\\_invalid} \\to \\lnot \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits\\_at\\_least\\_1})) $$</p>"},{"location":"mutual-timed-commitment-tutorial/#second-specification","title":"Second specification\u00b6","text":"<p>We consider other two ${\\rm ATL}$ specifications:</p> <ul> <li>If the first timeout has expired and commitment for secret $\\texttt{a}$ is invalid, then $\\texttt{B}$ can recover his funds plus $\\texttt{A}$'s penalty without revealing its secret $\\texttt{b}$ (if it has not done it yet):</li> </ul> <p>$$ AG((     \\lnot\\mathsf{public\\_secret\\_b\\_is\\_valid}     \\wedge \\mathsf{timeout\\_1\\_expired}     \\wedge \\mathsf{private\\_secret\\_a\\_is\\_invalid})   \\to \\langle A \\rangle F (     \\mathsf{part\\_B\\_total\\_deposits\\_is\\_2}     \\wedge \\lnot\\mathsf{public\\_secret\\_b\\_is\\_valid})) $$</p> <p>We require the definition of the following propositions:</p> <ul> <li><code>public_secret_b_is_valid</code>: the secret <code>b</code> is published and it is the valid secret of the commitment;</li> <li><code>timeout_1_expired</code>: the first timeout has expired;</li> <li><code>private_secret_a_is_invalid</code>: see above;</li> <li><code>part_B_total_deposits_is_at_least_2</code>:  the total of deposits held by participant $\\texttt{B}$ is at least 2.</li> </ul>"},{"location":"mutual-timed-commitment-tutorial/#third-specification","title":"Third specification\u00b6","text":"<p>The third and last ${\\rm ATL}$ specification that we will consider is:</p> <ul> <li>If participant $\\texttt{B}$ commits to his secret and the first timeout has not expired yet, then it is guaranteed that $\\texttt{B}$ always has a strategy to take at least 1 bitcoin:</li> </ul> <p>$$ AG((\\mathsf{contract\\_is\\_initialized}  \\wedge \\lnot\\mathsf{timeout\\_1\\_expired}  \\wedge \\mathsf{private\\_secret\\_b\\_is\\_valid}) \\to \\langle B\\rangle F(\\mathsf{part\\_B\\_total\\_deposits\\_is\\_at\\_least\\_1})) $$</p> <p>We require the definition of the following propositions:</p> <ul> <li><code>contract_is_initialized</code>: this proposition is true if the contract has been initialized;</li> <li><code>timeout_1_expired</code>: see above;</li> <li><code>private_secret_b_is_valid</code>: the secret commitment for <code>b</code> is valid;</li> <li><code>part_B_total_deposits_at_least_1</code>: the total of deposits held by participant $\\texttt{B}$ is at least 1</li> </ul>"},{"location":"mutual-timed-commitment-tutorial/#translation-to-ispl","title":"Translation to ISPL\u00b6","text":"<p>Finally, we are ready to produce the ISPL program file. To do so, we use instantiate the <code>Compiler</code> class with the contract, the formulae and the custom evaluation rules:</p>"},{"location":"mutual-timed-commitment-tutorial/#atl-model-checking-with-mcmas","title":"ATL model checking with MCMAS\u00b6","text":""},{"location":"mutual-timed-commitment-tutorial/#flawed-mutual-timed-commitment","title":"Flawed Mutual Timed Commitment\u00b6","text":"<p>Here we consider the case where $t_1 \\ge t_2$, for example, $t_1 = t_2 = 1$. In particular, we replace <code>after 2</code> with <code>after 1</code>:</p>"},{"location":"mutual-timed-commitment-tutorial/#additional-features","title":"Additional features\u00b6","text":""},{"location":"mutual-timed-commitment-tutorial/#generation-of-witnessescounterexamples","title":"Generation of witnesses/counterexamples\u00b6","text":"<p>For simple formulae (in particular, ECTLK formulae), MCMAS can generate witnesses for true formulae and counterexamples for false formulae.</p> <p>Continuing with the mutual timed commitment contract, we consider two ${\\rm CTL}$ specifications:</p> <ul> <li>There exist an execution path such that eventually the contract funds are zeroed:</li> </ul> <p>$$ EF(\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <ul> <li>For all execution paths, eventually on each path, the contract funds are zeroed:</li> </ul> <p>$$ AF(\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>In code:</p>"},{"location":"mutual-timed-commitment-tutorial/#simulation-of-the-ispl-model","title":"Simulation of the ISPL model\u00b6","text":"<p>We can use the MCMAS CLI tool to simulate the model, and so to debug the execution of the target BitML contract.</p> <p>To do so, we can execute:</p> <pre><code>./mcmas -s docs/mutual-timed-commitment-tutorial-assets/model.ispl \n</code></pre> <p>Then, it starts an interactive session where the user can provide input to select the action tuple (one action per agent).</p> <p>In the proposed simulation of length 3, we take the following action tuples:</p> <ul> <li><code>Environment : schedule_part_B; Agent_A : nop; Agent_B : commit_valid_secret_b</code>: the Environment schedules agent B, which commits to a valid secret;</li> <li><code>Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : nop</code>: the Environment schedules agent A, which commits to a valid secret;</li> <li><code>Environment : schedule_part_B; Agent_A : nop; Agent_B : initialize_contract</code>: the Environment schedules agent B, which initializes the contract.</li> </ul> <p>Follows the output of the tool:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0\n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law.\n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./mcmas -s docs/mutual-timed-commitment-tutorial-assets/model.ispl\n\ndocs/mutual-timed-commitment-tutorial-assets/model.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\n\n--------- Initial state ---------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = not_committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = unset\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_A\n  private_secret_a = not_committed\nAgent Agent_B\n  private_secret_b = not_committed\n----------------------------\nEnabled actions:\n1 : Environment : schedule_part_B; Agent_A : nop; Agent_B : commit_valid_secret_b\n2 : Environment : schedule_part_B; Agent_A : nop; Agent_B : commit_invalid_secret_b\n3 : Environment : schedule_part_B; Agent_A : commit_invalid_secret_a; Agent_B : commit_valid_secret_b\n4 : Environment : schedule_part_B; Agent_A : nop; Agent_B : nop\n5 : Environment : schedule_part_B; Agent_A : commit_valid_secret_a; Agent_B : commit_valid_secret_b\n6 : Environment : schedule_part_B; Agent_A : commit_valid_secret_a; Agent_B : commit_invalid_secret_b\n7 : Environment : schedule_part_B; Agent_A : commit_invalid_secret_a; Agent_B : commit_invalid_secret_b\n8 : Environment : schedule_part_B; Agent_A : commit_invalid_secret_a; Agent_B : nop\n9 : Environment : schedule_part_B; Agent_A : commit_valid_secret_a; Agent_B : nop\n10 : Environment : schedule_part_A; Agent_A : nop; Agent_B : commit_invalid_secret_b\n11 : Environment : schedule_part_A; Agent_A : commit_invalid_secret_a; Agent_B : commit_valid_secret_b\n12 : Environment : schedule_part_A; Agent_A : commit_invalid_secret_a; Agent_B : nop\n13 : Environment : schedule_part_A; Agent_A : nop; Agent_B : commit_valid_secret_b\n14 : Environment : schedule_part_A; Agent_A : nop; Agent_B : nop\n15 : Environment : schedule_part_A; Agent_A : commit_invalid_secret_a; Agent_B : commit_invalid_secret_b\n16 : Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : nop\n17 : Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : commit_valid_secret_b\n18 : Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : commit_invalid_secret_b\nPlease choose one, or type 0 to backtrack or -1 to quit:\n1\n\n--------- Current state ---------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = not_committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_A\n  private_secret_a = not_committed\nAgent Agent_B\n  private_secret_b = valid\n----------------------------\nEnabled actions:\n1 : Environment : schedule_part_B; Agent_A : nop; Agent_B : reveal_secret_b\n2 : Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : nop\n3 : Environment : schedule_part_B; Agent_A : nop; Agent_B : nop\n4 : Environment : schedule_part_A; Agent_A : nop; Agent_B : nop\n5 : Environment : schedule_part_A; Agent_A : commit_valid_secret_a; Agent_B : reveal_secret_b\n6 : Environment : schedule_part_A; Agent_A : nop; Agent_B : reveal_secret_b\n7 : Environment : schedule_part_B; Agent_A : commit_invalid_secret_a; Agent_B : nop\n8 : Environment : schedule_part_A; Agent_A : commit_invalid_secret_a; Agent_B : nop\n9 : Environment : schedule_part_B; Agent_A : commit_valid_secret_a; Agent_B : reveal_secret_b\n10 : Environment : schedule_part_A; Agent_A : commit_invalid_secret_a; Agent_B : reveal_secret_b\n11 : Environment : schedule_part_B; Agent_A : commit_invalid_secret_a; Agent_B : reveal_secret_b\n12 : Environment : schedule_part_B; Agent_A : commit_valid_secret_a; Agent_B : nop\nPlease choose one, or type 0 to backtrack or -1 to quit:\n2\n\n--------- Current state ---------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = false\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_A\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_A\n  private_secret_a = valid\nAgent Agent_B\n  private_secret_b = valid\n----------------------------\nEnabled actions:\n1 : Environment : schedule_part_B; Agent_A : initialize_contract; Agent_B : nop\n2 : Environment : schedule_part_B; Agent_A : reveal_secret_a; Agent_B : reveal_secret_b\n3 : Environment : schedule_part_B; Agent_A : reveal_secret_a; Agent_B : nop\n4 : Environment : schedule_part_B; Agent_A : initialize_contract; Agent_B : initialize_contract\n5 : Environment : schedule_part_B; Agent_A : nop; Agent_B : reveal_secret_b\n6 : Environment : schedule_part_B; Agent_A : initialize_contract; Agent_B : reveal_secret_b\n7 : Environment : schedule_part_B; Agent_A : nop; Agent_B : initialize_contract\n8 : Environment : schedule_part_A; Agent_A : initialize_contract; Agent_B : reveal_secret_b\n9 : Environment : schedule_part_A; Agent_A : initialize_contract; Agent_B : nop\n10 : Environment : schedule_part_A; Agent_A : initialize_contract; Agent_B : initialize_contract\n11 : Environment : schedule_part_B; Agent_A : reveal_secret_a; Agent_B : initialize_contract\n12 : Environment : schedule_part_B; Agent_A : nop; Agent_B : nop\n13 : Environment : schedule_part_A; Agent_A : nop; Agent_B : initialize_contract\n14 : Environment : schedule_part_A; Agent_A : nop; Agent_B : reveal_secret_b\n15 : Environment : schedule_part_A; Agent_A : reveal_secret_a; Agent_B : reveal_secret_b\n16 : Environment : schedule_part_A; Agent_A : nop; Agent_B : nop\n17 : Environment : schedule_part_A; Agent_A : reveal_secret_a; Agent_B : nop\n18 : Environment : schedule_part_A; Agent_A : reveal_secret_a; Agent_B : initialize_contract\nPlease choose one, or type 0 to backtrack or -1 to quit:\n7\n\n--------- Current state ---------\nAgent Environment\n  contract_funds = 2\n  contract_initialized = true\n  part_A_total_deposits = 0\n  part_B_total_deposits = 0\n  public_secret_a = committed\n  public_secret_b = committed\n  status_node_0_withdraw = disabled\n  status_node_1_withdraw = disabled\n  status_node_2_split = disabled\n  status_node_3_reveal = disabled\n  status_node_4_withdraw = disabled\n  status_node_6_reveal = disabled\n  status_node_7_withdraw = disabled\n  time = 0\n  last_action = action_schedule_part_B\n  part_A_is_done = false\n  part_B_is_done = false\nAgent Agent_A\n  private_secret_a = valid\nAgent Agent_B\n  private_secret_b = valid\n----------------------------\nEnabled actions:\n1 : Environment : schedule_part_B; Agent_A : nop; Agent_B : reveal_secret_b\n2 : Environment : schedule_part_A; Agent_A : reveal_secret_a; Agent_B : nop\n3 : Environment : schedule_part_B; Agent_A : nop; Agent_B : nop\n4 : Environment : schedule_part_A; Agent_A : reveal_secret_a; Agent_B : reveal_secret_b\n5 : Environment : schedule_part_A; Agent_A : nop; Agent_B : reveal_secret_b\n6 : Environment : schedule_part_A; Agent_A : nop; Agent_B : nop\n7 : Environment : schedule_part_B; Agent_A : reveal_secret_a; Agent_B : reveal_secret_b\n8 : Environment : schedule_part_B; Agent_A : reveal_secret_a; Agent_B : nop\nPlease choose one, or type 0 to backtrack or -1 to quit:\n-1\n</code></pre>"},{"location":"mutual-timed-commitment-tutorial/#visualization-of-the-model","title":"Visualization of the model\u00b6","text":"<p>MCMAS can also render the ISPL model of our BitML contract in DOT format.</p> <p>Since the graph of the mutual timed commitment contract would be too large, to exhibit this feature, we consider a simple contract where a participant $\\texttt{A}$ wants to transfer 1 bitcoin to $\\texttt{B}$.</p>"},{"location":"tutorial/","title":"More contracts","text":"<p>In this tutorial, we will walk through several examples on how to use our BitML-to-ISPL compiler, and how to interpret the MCMAS output.</p> <p>We put all required imports and constants in the following code block:</p> In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom bitml2mcmas.bitml.parser.parser import BitMLParser\nfrom bitml2mcmas.compiler._private.terms import PrivateSecretValues, PublicSecretValues\nfrom bitml2mcmas.compiler.core import Compiler\nfrom bitml2mcmas.mcmas.ast import EvaluationRule\nfrom bitml2mcmas.mcmas.boolcond import EqualTo, EnvironmentIdAtom, IntAtom, GreaterThanOrEqual, IdAtom\nfrom bitml2mcmas.mcmas.formula import AtomicFormula, DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula, \\\n    AndFormula, OrFormula\nfrom bitml2mcmas.mcmas.to_string import interpreted_system_to_string\n</pre> from pathlib import Path from bitml2mcmas.bitml.parser.parser import BitMLParser from bitml2mcmas.compiler._private.terms import PrivateSecretValues, PublicSecretValues from bitml2mcmas.compiler.core import Compiler from bitml2mcmas.mcmas.ast import EvaluationRule from bitml2mcmas.mcmas.boolcond import EqualTo, EnvironmentIdAtom, IntAtom, GreaterThanOrEqual, IdAtom from bitml2mcmas.mcmas.formula import AtomicFormula, DiamondEventuallyFormula, AGFormula, ImpliesFormula, NotFormula, \\     AndFormula, OrFormula from bitml2mcmas.mcmas.to_string import interpreted_system_to_string In\u00a0[2]: Copied! <pre># Agent names\nAGENT_A = \"Agent_A\"\nAGENT_B = \"Agent_B\"\nAGENT_M = \"Agent_M\"\nAGENT_G = \"Agent_G\"\n\n# State variable names\n# A boolean keeping track whether participant A is ready to move to the next timestep\nVAR_PART_A_IS_DONE = \"part_A_is_done\"\n# A boolean keeping track whether participant B is ready to move to the next timestep\nVAR_PART_B_IS_DONE = \"part_B_is_done\"\n# An integer keeping track of the funds currently held by the contract\nVAR_CONTRACT_FUNDS = \"contract_funds\"\n# An integer keeping track of the total deposits held by participant A\nVAR_PART_A_TOTAL_DEPOSITS = \"part_A_total_deposits\"\n# An integer keeping track of the total deposits held by participant B\nVAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\"\n# The private state of the secret 'a', an enumeration of {not_committed, valid, invalid}\nVAR_PRIVATE_SECRET_A = \"private_secret_a\"\n# The state of the public secret 'a', an enumeration of {not_committed, committed, valid}\nVAR_PUBLIC_SECRET_A = \"public_secret_a\"\n# The state of the private secret 'b', an enumeration of {not_committed, valid, invalid}\nVAR_PRIVATE_SECRET_B = \"private_secret_b\"\n# The state of the public secret 'b', an enumeration of {not_committed, committed, valid}\nVAR_PUBLIC_SECRET_B = \"public_secret_b\"\n\n# propositions and their evaluation rules (some of them are added by the compiler by default)\n#####\n# part_A_is_done: true iff the state variable 'part_A_is_done' is true\n# Definition: part_A_is_done if (Environment.part_A_is_done = true);\nPART_A_IS_DONE_PROP = \"part_A_is_done\"\nPART_A_IS_DONE = AtomicFormula(PART_A_IS_DONE_PROP)\n#####\n# part_B_is_done: true iff the state variable 'part_B_is_done' is true\n# Definition: part_B_is_done if (Environment.part_B_is_done = true);\nPART_B_IS_DONE_PROP = \"part_B_is_done\"\nPART_B_IS_DONE = AtomicFormula(PART_B_IS_DONE_PROP)\n#####\n# contract_is_initialized: true iff the contract is initialized or not in the current state\n# Definition: contract_is_initialized if (Environment.contract_initialized = true);\nCONTRACT_IS_INITIALIZED_PROP = \"contract_is_initialized\"\nCONTRACT_IS_INITIALIZED = AtomicFormula(CONTRACT_IS_INITIALIZED_PROP)\n#####\n# contract_funds_are_zero: true iff there are no more funds deposited in the contracts\n# Definition: contract_funds_are_zero if (Environment.contract_funds = 0);\nCONTRACT_FUNDS_ARE_ZERO_PROP = \"contract_funds_are_zero\"\nCONTRACT_FUNDS_ARE_ZERO = AtomicFormula(CONTRACT_FUNDS_ARE_ZERO_PROP)\nCONTRACT_FUNDS_ARE_ZERO_ER = EvaluationRule(\n    CONTRACT_FUNDS_ARE_ZERO_PROP, \n    EqualTo(EnvironmentIdAtom(VAR_CONTRACT_FUNDS), IntAtom(0))\n)\n#####\n# timeout_1_has_expired: true iff the first timeout in the contract has expired\n# Definition: timeout_1_has_expired if (Environment.time &gt;= 1);\nTIMEOUT_1_HAS_EXPIRED_PROP = \"timeout_1_has_expired\"\nTIMEOUT_1_HAS_EXPIRED = AtomicFormula(TIMEOUT_1_HAS_EXPIRED_PROP)\n#####\n# part_A_total_deposits_is_1: the total of deposits held by participant A is equal to 1\n# Definition: part_A_total_deposits_is_1 if (Environment.part_A_total_deposits = 1);\nPART_A_TOTAL_DEPOSITS_IS_1_PROP = \"part_A_total_deposits_is_1\"\nPART_A_TOTAL_DEPOSITS_IS_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_1_PROP)\nPART_A_TOTAL_DEPOSITS_IS_1_ER = EvaluationRule(\n    PART_A_TOTAL_DEPOSITS_IS_1_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1))\n)\n#####\n# part_A_total_deposits_is_at_least_1: the total of deposits held by participant A is at least 1\n# Definition: part_A_total_deposits_is_at_least_1 if (Environment.part_A_total_deposits &gt;= 1);\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_A_total_deposits_is_at_least_1\"\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP)\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(\n    PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1))\n)\n#####\n# part_B_total_deposits_is_1: the total of deposits held by participant B is equal to 1\n# Definition: part_B_total_deposits_is_1 if (Environment.part_B_total_deposits = 1);\nPART_B_TOTAL_DEPOSITS_IS_1_PROP = \"part_B_total_deposits_is_1\"\nPART_B_TOTAL_DEPOSITS_IS_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_1_PROP)\nPART_B_TOTAL_DEPOSITS_IS_1_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_1_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1))\n)\n#####\n# part_B_total_deposits_is_at_least_1: the total of deposits held by participant B is at least 1\n# Definition: part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1);\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_B_total_deposits_is_at_least_1\"\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP)\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1))\n)\n#####\n# part_B_total_deposits_is_2: the total of deposits held by participant B is equal to 2\n# Definition: part_B_total_deposits_is_2 if (Environment.part_B_total_deposits = 2);\nPART_B_TOTAL_DEPOSITS_IS_2_PROP = \"part_B_total_deposits_is_2\"\nPART_B_TOTAL_DEPOSITS_IS_2 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_2_PROP)\nPART_B_TOTAL_DEPOSITS_IS_2_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_2_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(2))\n)\n#####\n# part_A_total_deposits_is_at_least_9: the total of deposits held by participant A is at least 9\n# Definition: part_A_total_deposits_is_at_least_9 if (Environment.part_A_total_deposits &gt;= 9);\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP = \"part_A_total_deposits_is_at_least_9\"\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP)\nPART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER = EvaluationRule(\n    PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(9))\n)\n#####\n# part_B_total_deposits_is_at_least_9: the total of deposits held by participant B is at least 9\n# Definition: part_B_total_deposits_is_at_least_9 if (Environment.part_B_total_deposits &gt;= 9);\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP = \"part_B_total_deposits_is_at_least_9\"\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP)\nPART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER = EvaluationRule(\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(9))\n)\n#####\n# part_A_total_deposits_is_10: the total of deposits held by participant A is 10\n# Definition: part_A_total_deposits_is_10 if (Environment.part_A_total_deposits = 10);\nPART_A_TOTAL_DEPOSITS_IS_10_PROP = \"part_A_total_deposits_is_10\"\nPART_A_TOTAL_DEPOSITS_IS_10 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_10_PROP)\nPART_A_TOTAL_DEPOSITS_IS_10_ER = EvaluationRule(\n    PART_A_TOTAL_DEPOSITS_IS_10_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(10))\n)\n####\n# private_secret_a_is_valid: the secret commitment for 'a' is valid\n# Definition: private_secret_a_is_valid if (Agent_A.private_secret_a = valid);\nPRIVATE_SECRET_A_IS_VALID_PROP = \"private_secret_a_is_valid\"\nPRIVATE_SECRET_A_IS_VALID = AtomicFormula(PRIVATE_SECRET_A_IS_VALID_PROP)\nPRIVATE_SECRET_A_IS_VALID_ER = EvaluationRule(\n    PRIVATE_SECRET_A_IS_VALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_A), IdAtom(PrivateSecretValues.VALID.value))\n)\n####\n# private_secret_b_is_valid: the secret commitment for 'b' is valid\n# Definition: private_secret_b_is_valid if (Agent_B.private_secret_b = valid);\nPRIVATE_SECRET_B_IS_VALID_PROP = \"private_secret_b_is_valid\"\nPRIVATE_SECRET_B_IS_VALID = AtomicFormula(PRIVATE_SECRET_B_IS_VALID_PROP)\nPRIVATE_SECRET_B_IS_VALID_ER = EvaluationRule(\n    PRIVATE_SECRET_B_IS_VALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_B), IdAtom(PrivateSecretValues.VALID.value))\n)\n####\n# private_secret_a_is_invalid: the secret commitment for 'a' is invalid\n# Definition: private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid);\nPRIVATE_SECRET_A_IS_INVALID_PROP = \"private_secret_a_is_invalid\"\nPRIVATE_SECRET_A_IS_INVALID = AtomicFormula(PRIVATE_SECRET_A_IS_INVALID_PROP)\nPRIVATE_SECRET_A_IS_INVALID_ER = EvaluationRule(\n    PRIVATE_SECRET_A_IS_INVALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_A), IdAtom(PrivateSecretValues.INVALID.value))\n)\n####\n# private_secret_b_is_invalid: the secret commitment for 'b' is invalid\n# Definition: private_secret_b_is_invalid if (Agent_B.private_secret_b = invalid);\nPRIVATE_SECRET_B_IS_INVALID_PROP = \"private_secret_b_is_invalid\"\nPRIVATE_SECRET_B_IS_INVALID = AtomicFormula(PRIVATE_SECRET_B_IS_INVALID_PROP)\nPRIVATE_SECRET_B_IS_INVALID_ER = EvaluationRule(\n    PRIVATE_SECRET_B_IS_INVALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_B), IdAtom(PrivateSecretValues.INVALID.value))\n)\n####\n# public_secret_a_is_valid: the secret commitment for 'a' is valid\n# Definition: public_secret_a_is_valid if (Environment.public_secret_a = valid);\nPUBLIC_SECRET_A_IS_VALID_PROP = \"public_secret_a_is_valid\"\nPUBLIC_SECRET_A_IS_VALID = AtomicFormula(PUBLIC_SECRET_A_IS_VALID_PROP)\nPUBLIC_SECRET_A_IS_VALID_ER = EvaluationRule(\n    PUBLIC_SECRET_A_IS_VALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PUBLIC_SECRET_A), IdAtom(PublicSecretValues.VALID.value))\n)\n####\n# public_secret_b_is_valid: the secret commitment for 'b' is invalid\n# Definition: public_secret_b_is_valid if (Environment.public_secret_b = invalid);\nPUBLIC_SECRET_B_IS_VALID_PROP = \"public_secret_b_is_valid\"\nPUBLIC_SECRET_B_IS_VALID = AtomicFormula(PUBLIC_SECRET_B_IS_VALID_PROP)\nPUBLIC_SECRET_B_IS_VALID_ER = EvaluationRule(\n    PUBLIC_SECRET_B_IS_VALID_PROP,\n    EqualTo(EnvironmentIdAtom(VAR_PUBLIC_SECRET_B), IdAtom(PublicSecretValues.VALID.value))\n)\n</pre> # Agent names AGENT_A = \"Agent_A\" AGENT_B = \"Agent_B\" AGENT_M = \"Agent_M\" AGENT_G = \"Agent_G\"  # State variable names # A boolean keeping track whether participant A is ready to move to the next timestep VAR_PART_A_IS_DONE = \"part_A_is_done\" # A boolean keeping track whether participant B is ready to move to the next timestep VAR_PART_B_IS_DONE = \"part_B_is_done\" # An integer keeping track of the funds currently held by the contract VAR_CONTRACT_FUNDS = \"contract_funds\" # An integer keeping track of the total deposits held by participant A VAR_PART_A_TOTAL_DEPOSITS = \"part_A_total_deposits\" # An integer keeping track of the total deposits held by participant B VAR_PART_B_TOTAL_DEPOSITS = \"part_B_total_deposits\" # The private state of the secret 'a', an enumeration of {not_committed, valid, invalid} VAR_PRIVATE_SECRET_A = \"private_secret_a\" # The state of the public secret 'a', an enumeration of {not_committed, committed, valid} VAR_PUBLIC_SECRET_A = \"public_secret_a\" # The state of the private secret 'b', an enumeration of {not_committed, valid, invalid} VAR_PRIVATE_SECRET_B = \"private_secret_b\" # The state of the public secret 'b', an enumeration of {not_committed, committed, valid} VAR_PUBLIC_SECRET_B = \"public_secret_b\"  # propositions and their evaluation rules (some of them are added by the compiler by default) ##### # part_A_is_done: true iff the state variable 'part_A_is_done' is true # Definition: part_A_is_done if (Environment.part_A_is_done = true); PART_A_IS_DONE_PROP = \"part_A_is_done\" PART_A_IS_DONE = AtomicFormula(PART_A_IS_DONE_PROP) ##### # part_B_is_done: true iff the state variable 'part_B_is_done' is true # Definition: part_B_is_done if (Environment.part_B_is_done = true); PART_B_IS_DONE_PROP = \"part_B_is_done\" PART_B_IS_DONE = AtomicFormula(PART_B_IS_DONE_PROP) ##### # contract_is_initialized: true iff the contract is initialized or not in the current state # Definition: contract_is_initialized if (Environment.contract_initialized = true); CONTRACT_IS_INITIALIZED_PROP = \"contract_is_initialized\" CONTRACT_IS_INITIALIZED = AtomicFormula(CONTRACT_IS_INITIALIZED_PROP) ##### # contract_funds_are_zero: true iff there are no more funds deposited in the contracts # Definition: contract_funds_are_zero if (Environment.contract_funds = 0); CONTRACT_FUNDS_ARE_ZERO_PROP = \"contract_funds_are_zero\" CONTRACT_FUNDS_ARE_ZERO = AtomicFormula(CONTRACT_FUNDS_ARE_ZERO_PROP) CONTRACT_FUNDS_ARE_ZERO_ER = EvaluationRule(     CONTRACT_FUNDS_ARE_ZERO_PROP,      EqualTo(EnvironmentIdAtom(VAR_CONTRACT_FUNDS), IntAtom(0)) ) ##### # timeout_1_has_expired: true iff the first timeout in the contract has expired # Definition: timeout_1_has_expired if (Environment.time &gt;= 1); TIMEOUT_1_HAS_EXPIRED_PROP = \"timeout_1_has_expired\" TIMEOUT_1_HAS_EXPIRED = AtomicFormula(TIMEOUT_1_HAS_EXPIRED_PROP) ##### # part_A_total_deposits_is_1: the total of deposits held by participant A is equal to 1 # Definition: part_A_total_deposits_is_1 if (Environment.part_A_total_deposits = 1); PART_A_TOTAL_DEPOSITS_IS_1_PROP = \"part_A_total_deposits_is_1\" PART_A_TOTAL_DEPOSITS_IS_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_1_PROP) PART_A_TOTAL_DEPOSITS_IS_1_ER = EvaluationRule(     PART_A_TOTAL_DEPOSITS_IS_1_PROP,     EqualTo(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1)) ) ##### # part_A_total_deposits_is_at_least_1: the total of deposits held by participant A is at least 1 # Definition: part_A_total_deposits_is_at_least_1 if (Environment.part_A_total_deposits &gt;= 1); PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_A_total_deposits_is_at_least_1\" PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP) PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(     PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(1)) ) ##### # part_B_total_deposits_is_1: the total of deposits held by participant B is equal to 1 # Definition: part_B_total_deposits_is_1 if (Environment.part_B_total_deposits = 1); PART_B_TOTAL_DEPOSITS_IS_1_PROP = \"part_B_total_deposits_is_1\" PART_B_TOTAL_DEPOSITS_IS_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_1_PROP) PART_B_TOTAL_DEPOSITS_IS_1_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_1_PROP,     EqualTo(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1)) ) ##### # part_B_total_deposits_is_at_least_1: the total of deposits held by participant B is at least 1 # Definition: part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1); PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_B_total_deposits_is_at_least_1\" PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP) PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(1)) ) ##### # part_B_total_deposits_is_2: the total of deposits held by participant B is equal to 2 # Definition: part_B_total_deposits_is_2 if (Environment.part_B_total_deposits = 2); PART_B_TOTAL_DEPOSITS_IS_2_PROP = \"part_B_total_deposits_is_2\" PART_B_TOTAL_DEPOSITS_IS_2 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_2_PROP) PART_B_TOTAL_DEPOSITS_IS_2_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_2_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(2)) ) ##### # part_A_total_deposits_is_at_least_9: the total of deposits held by participant A is at least 9 # Definition: part_A_total_deposits_is_at_least_9 if (Environment.part_A_total_deposits &gt;= 9); PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP = \"part_A_total_deposits_is_at_least_9\" PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP) PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER = EvaluationRule(     PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(9)) ) ##### # part_B_total_deposits_is_at_least_9: the total of deposits held by participant B is at least 9 # Definition: part_B_total_deposits_is_at_least_9 if (Environment.part_B_total_deposits &gt;= 9); PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP = \"part_B_total_deposits_is_at_least_9\" PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9 = AtomicFormula(PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP) PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER = EvaluationRule(     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_B_TOTAL_DEPOSITS), IntAtom(9)) ) ##### # part_A_total_deposits_is_10: the total of deposits held by participant A is 10 # Definition: part_A_total_deposits_is_10 if (Environment.part_A_total_deposits = 10); PART_A_TOTAL_DEPOSITS_IS_10_PROP = \"part_A_total_deposits_is_10\" PART_A_TOTAL_DEPOSITS_IS_10 = AtomicFormula(PART_A_TOTAL_DEPOSITS_IS_10_PROP) PART_A_TOTAL_DEPOSITS_IS_10_ER = EvaluationRule(     PART_A_TOTAL_DEPOSITS_IS_10_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_A_TOTAL_DEPOSITS), IntAtom(10)) ) #### # private_secret_a_is_valid: the secret commitment for 'a' is valid # Definition: private_secret_a_is_valid if (Agent_A.private_secret_a = valid); PRIVATE_SECRET_A_IS_VALID_PROP = \"private_secret_a_is_valid\" PRIVATE_SECRET_A_IS_VALID = AtomicFormula(PRIVATE_SECRET_A_IS_VALID_PROP) PRIVATE_SECRET_A_IS_VALID_ER = EvaluationRule(     PRIVATE_SECRET_A_IS_VALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_A), IdAtom(PrivateSecretValues.VALID.value)) ) #### # private_secret_b_is_valid: the secret commitment for 'b' is valid # Definition: private_secret_b_is_valid if (Agent_B.private_secret_b = valid); PRIVATE_SECRET_B_IS_VALID_PROP = \"private_secret_b_is_valid\" PRIVATE_SECRET_B_IS_VALID = AtomicFormula(PRIVATE_SECRET_B_IS_VALID_PROP) PRIVATE_SECRET_B_IS_VALID_ER = EvaluationRule(     PRIVATE_SECRET_B_IS_VALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_B), IdAtom(PrivateSecretValues.VALID.value)) ) #### # private_secret_a_is_invalid: the secret commitment for 'a' is invalid # Definition: private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid); PRIVATE_SECRET_A_IS_INVALID_PROP = \"private_secret_a_is_invalid\" PRIVATE_SECRET_A_IS_INVALID = AtomicFormula(PRIVATE_SECRET_A_IS_INVALID_PROP) PRIVATE_SECRET_A_IS_INVALID_ER = EvaluationRule(     PRIVATE_SECRET_A_IS_INVALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_A), IdAtom(PrivateSecretValues.INVALID.value)) ) #### # private_secret_b_is_invalid: the secret commitment for 'b' is invalid # Definition: private_secret_b_is_invalid if (Agent_B.private_secret_b = invalid); PRIVATE_SECRET_B_IS_INVALID_PROP = \"private_secret_b_is_invalid\" PRIVATE_SECRET_B_IS_INVALID = AtomicFormula(PRIVATE_SECRET_B_IS_INVALID_PROP) PRIVATE_SECRET_B_IS_INVALID_ER = EvaluationRule(     PRIVATE_SECRET_B_IS_INVALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PRIVATE_SECRET_B), IdAtom(PrivateSecretValues.INVALID.value)) ) #### # public_secret_a_is_valid: the secret commitment for 'a' is valid # Definition: public_secret_a_is_valid if (Environment.public_secret_a = valid); PUBLIC_SECRET_A_IS_VALID_PROP = \"public_secret_a_is_valid\" PUBLIC_SECRET_A_IS_VALID = AtomicFormula(PUBLIC_SECRET_A_IS_VALID_PROP) PUBLIC_SECRET_A_IS_VALID_ER = EvaluationRule(     PUBLIC_SECRET_A_IS_VALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PUBLIC_SECRET_A), IdAtom(PublicSecretValues.VALID.value)) ) #### # public_secret_b_is_valid: the secret commitment for 'b' is invalid # Definition: public_secret_b_is_valid if (Environment.public_secret_b = invalid); PUBLIC_SECRET_B_IS_VALID_PROP = \"public_secret_b_is_valid\" PUBLIC_SECRET_B_IS_VALID = AtomicFormula(PUBLIC_SECRET_B_IS_VALID_PROP) PUBLIC_SECRET_B_IS_VALID_ER = EvaluationRule(     PUBLIC_SECRET_B_IS_VALID_PROP,     EqualTo(EnvironmentIdAtom(VAR_PUBLIC_SECRET_B), IdAtom(PublicSecretValues.VALID.value)) ) In\u00a0[3]: Copied! <pre>bitml_timed_commitment = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n    (secret \"A\" a \"0001a\")\n  )\n  (choice\n    (reveal (a) (withdraw \"A\"))\n    (after 1 (withdraw \"B\"))\n  )\n)\n\"\"\"\n</pre> bitml_timed_commitment = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\")  (contract   (pre     (deposit \"A\" 1 \"txA@0\")     (secret \"A\" a \"0001a\")   )   (choice     (reveal (a) (withdraw \"A\"))     (after 1 (withdraw \"B\"))   ) ) \"\"\"  <p>We will verify the following ${\\rm ATL}$ specifications:</p> <ul> <li>Participant $A$ has a strategy to make sure the contract is liquidated: $$ AG(\\mathsf{contract\\_is\\_initialized} \\to \\langle\\mathsf{A}\\rangle(\\mathsf{contract\\_funds\\_is\\_zero})) $$</li> <li>Participant $B$ has a strategy to make sure the contract is liquidated: $$AG(\\mathsf{contract\\_is\\_initialized} \\to \\langle\\mathsf{B}\\rangle(\\mathsf{contract\\_funds\\_is\\_zero}))$$</li> <li>Participant $A$ has a strategy to recover his funds whenever he commits to a valid secret (wrong attempt): $$ AG((A.\\mathsf{private\\_secret\\_a} = \\mathsf{valid}) \\to \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits} = 1)) $$</li> <li>Participant $A$ has a strategy to recover his funds whenever he commits to a valid secret AND timeout has not expired: $$AG((A.\\mathsf{private\\_secret\\_a} = \\mathsf{valid} \\wedge \\mathsf{time} &lt; t \\wedge \\lnot\\mathsf{A\\_is\\_done}) \\to \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits} = 1))$$</li> <li>If $A$ is dishonest, then $B$ can always find a way to withdraw the penalty: $$ AG(A.\\mathsf{private\\_secret\\_a} = \\mathsf{invalid}) \\to \\langle A\\rangle F (\\mathsf{part\\_B\\_total\\_deposits}=1)) $$</li> </ul> <p>The Python code to produce the ISPL is:</p> In\u00a0[4]: Copied! <pre># parse the contract\nparser = BitMLParser()\ncontract = parser(bitml_timed_commitment)\n\n# AG(contract_is_initialized A&gt; &lt;Agent_A&gt;F(contract_funds_are_zero))\nAGENT_A_CAN_ENFORCE_LIQUIDITY = AGFormula(\n    ImpliesFormula(\n        CONTRACT_IS_INITIALIZED,\n        DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO),\n    )\n)\n# AG(contract_is_initialized -&gt; &lt;Agent_B&gt;F(contract_funds_are_zero))\nAGENT_B_CAN_ENFORCE_LIQUIDITY = AGFormula(\n    ImpliesFormula(\n        CONTRACT_IS_INITIALIZED,\n        DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO),\n    )\n)\n# AG(private_secret_a_is_valid -&gt; &lt;Agent_B&gt;F(contract_funds_are_zero))\nAGENT_A_HONEST_CAN_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        PRIVATE_SECRET_A_IS_VALID,\n        DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_1),\n    )\n)\n# AG(\n#   (private_secret_a_is_valid and !timeout_1_has_expired and !part_A_is_done) \n#   -&gt; &lt;Agent_B&gt;F(contract_funds_are_zero))\nAGENT_A_HONEST_CAN_RECOVER_FUNDS_IF_TIMEOUT_NOT_EXPIRED = AGFormula(\n    ImpliesFormula(\n        AndFormula(PRIVATE_SECRET_A_IS_VALID, \n                   AndFormula(\n                       NotFormula(TIMEOUT_1_HAS_EXPIRED), \n                       NotFormula(PART_A_IS_DONE))),\n        DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_1),\n    )\n)\n\n# AG(private_secret_a_is_invalid -&gt; &lt;Agent_B&gt;F(part_B_total_deposits_is_1))\nIF_AGENT_A_IS_DISHONEST_AGENT_B_GETS_A_PENALTY = AGFormula(\n    ImpliesFormula(\n        PRIVATE_SECRET_A_IS_INVALID,\n        DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_1)\n    )\n)\n\nformulae = [\n    AGENT_A_CAN_ENFORCE_LIQUIDITY,\n    AGENT_B_CAN_ENFORCE_LIQUIDITY,\n    AGENT_A_HONEST_CAN_RECOVER_FUNDS,\n    AGENT_A_HONEST_CAN_RECOVER_FUNDS_IF_TIMEOUT_NOT_EXPIRED,\n    IF_AGENT_A_IS_DISHONEST_AGENT_B_GETS_A_PENALTY\n]\nevaluation_rules = [\n    CONTRACT_FUNDS_ARE_ZERO_ER,\n    PART_A_TOTAL_DEPOSITS_IS_1_ER,\n    PART_B_TOTAL_DEPOSITS_IS_1_ER\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system = compiler.compile()\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\n_ = Path(\"01-timed-commitment/contract.ispl\").write_text(interpreted_system_str)\n</pre> # parse the contract parser = BitMLParser() contract = parser(bitml_timed_commitment)  # AG(contract_is_initialized A&gt; F(contract_funds_are_zero)) AGENT_A_CAN_ENFORCE_LIQUIDITY = AGFormula(     ImpliesFormula(         CONTRACT_IS_INITIALIZED,         DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO),     ) ) # AG(contract_is_initialized -&gt; F(contract_funds_are_zero)) AGENT_B_CAN_ENFORCE_LIQUIDITY = AGFormula(     ImpliesFormula(         CONTRACT_IS_INITIALIZED,         DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO),     ) ) # AG(private_secret_a_is_valid -&gt; F(contract_funds_are_zero)) AGENT_A_HONEST_CAN_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         PRIVATE_SECRET_A_IS_VALID,         DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_1),     ) ) # AG( #   (private_secret_a_is_valid and !timeout_1_has_expired and !part_A_is_done)  #   -&gt; F(contract_funds_are_zero)) AGENT_A_HONEST_CAN_RECOVER_FUNDS_IF_TIMEOUT_NOT_EXPIRED = AGFormula(     ImpliesFormula(         AndFormula(PRIVATE_SECRET_A_IS_VALID,                     AndFormula(                        NotFormula(TIMEOUT_1_HAS_EXPIRED),                         NotFormula(PART_A_IS_DONE))),         DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_1),     ) )  # AG(private_secret_a_is_invalid -&gt; F(part_B_total_deposits_is_1)) IF_AGENT_A_IS_DISHONEST_AGENT_B_GETS_A_PENALTY = AGFormula(     ImpliesFormula(         PRIVATE_SECRET_A_IS_INVALID,         DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_1)     ) )  formulae = [     AGENT_A_CAN_ENFORCE_LIQUIDITY,     AGENT_B_CAN_ENFORCE_LIQUIDITY,     AGENT_A_HONEST_CAN_RECOVER_FUNDS,     AGENT_A_HONEST_CAN_RECOVER_FUNDS_IF_TIMEOUT_NOT_EXPIRED,     IF_AGENT_A_IS_DISHONEST_AGENT_B_GETS_A_PENALTY ] evaluation_rules = [     CONTRACT_FUNDS_ARE_ZERO_ER,     PART_A_TOTAL_DEPOSITS_IS_1_ER,     PART_B_TOTAL_DEPOSITS_IS_1_ER ] compiler = Compiler(     contract, formulae, evaluation_rules=evaluation_rules ) interpreted_system = compiler.compile() interpreted_system_str = interpreted_system_to_string(interpreted_system) _ = Path(\"01-timed-commitment/contract.ispl\").write_text(interpreted_system_str) <p>The output file <code>01-timed-commitment/contract.ispl</code> is pasted below:</p> <pre><code>Semantics=SingleAssignment;\nAgent Environment\n  Obsvars:\n    time: 0..1;\n    contract_funds: 0..1;\n    part_A_total_deposits: 0..1;\n    part_B_total_deposits: 0..1;\n    public_secret_a: {committed, not_committed, valid};\n    contract_initialized: boolean;\n    status_node_0_withdraw: {disabled, enabled, executed};\n    status_node_1_reveal: {disabled, enabled, executed};\n    status_node_2_withdraw: {disabled, enabled, executed};\n  end Obsvars\n  Vars:\n    part_A_is_done: boolean;\n    part_B_is_done: boolean;\n    last_action: {action_delay, action_schedule_part_A, action_schedule_part_B, unset};\n  end Vars\n\n  Actions = {delay, schedule_part_A, schedule_part_B};\n  Protocol:\n    (part_A_is_done = false): {schedule_part_A};\n    (part_B_is_done = false): {schedule_part_B};\n    Other: {delay};\n  end Protocol\n  Evolution:\n    part_A_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_B_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_A_is_done = true if (((Action = schedule_part_A) and (Agent_A.Action = nop)) and (part_A_is_done = false));\n    part_B_is_done = true if (((Action = schedule_part_B) and (Agent_B.Action = nop)) and (part_B_is_done = false));\n    time = (time + 1) if (((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true))) and (time &lt; 1));\n    public_secret_a = committed if (((public_secret_a = not_committed) and ((Agent_A.Action = commit_valid_secret_a) or (Agent_A.Action = commit_invalid_secret_a))) and (Action = schedule_part_A));\n    public_secret_a = valid if (((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)) and (public_secret_a = committed));\n    contract_initialized = true if (((contract_initialized = false) and ((public_secret_a = committed) or (public_secret_a = valid))) and (((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    status_node_0_withdraw = executed if (((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)));\n    status_node_0_withdraw = enabled if (((status_node_1_reveal = executed) or (((Agent_A.Action = exec_node_1_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_reveal) and (Action = schedule_part_B)))) and (status_node_0_withdraw = disabled));\n    status_node_1_reveal = executed if (((Agent_A.Action = exec_node_1_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_reveal) and (Action = schedule_part_B)));\n    status_node_1_reveal = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_1_reveal = disabled)) and ((public_secret_a = valid) or ((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)))) and (!((status_node_2_withdraw = executed) or (((Agent_A.Action = exec_node_2_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_withdraw) and (Action = schedule_part_B))))));\n    status_node_1_reveal = disabled if ((status_node_2_withdraw = executed) or (((Agent_A.Action = exec_node_2_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    status_node_2_withdraw = executed if (((Agent_A.Action = exec_node_2_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_withdraw) and (Action = schedule_part_B)));\n    status_node_2_withdraw = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_2_withdraw = disabled)) and ((time &gt;= 1) or ((time = 0) and (Action = delay)))) and (!((status_node_1_reveal = executed) or (((Agent_A.Action = exec_node_1_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_reveal) and (Action = schedule_part_B))))));\n    status_node_2_withdraw = disabled if ((status_node_1_reveal = executed) or (((Agent_A.Action = exec_node_1_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_reveal) and (Action = schedule_part_B))));\n    last_action = action_schedule_part_B if (Action = schedule_part_B);\n    last_action = action_schedule_part_A if (Action = schedule_part_A);\n    last_action = action_delay if (Action = delay);\n  end Evolution\nend Agent\n\nAgent Agent_A\n  Lobsvars = {part_A_is_done};\n  Vars:\n    private_secret_a: {invalid, not_committed, valid};\n  end Vars\n\n  Actions = {commit_invalid_secret_a, commit_valid_secret_a, exec_node_0_withdraw, exec_node_1_reveal, exec_node_2_withdraw, initialize_contract, nop, reveal_secret_a};\n  Protocol:\n    (((Environment.contract_initialized = false) and (private_secret_a = not_committed)) and (Environment.part_A_is_done = false)): {commit_invalid_secret_a, commit_valid_secret_a, nop};\n    (((private_secret_a = valid) and (Environment.public_secret_a = committed)) and (Environment.part_A_is_done = false)): {nop, reveal_secret_a};\n    (((Environment.contract_initialized = false) and (Environment.part_A_is_done = false)) and ((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_reveal = enabled) and (Environment.part_A_is_done = false)): {exec_node_1_reveal, nop};\n    ((Environment.status_node_2_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_2_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    private_secret_a = valid if ((((Action = commit_valid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n    private_secret_a = invalid if ((((Action = commit_invalid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n  end Evolution\nend Agent\nAgent Agent_B\n  Lobsvars = {part_B_is_done};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {exec_node_0_withdraw, exec_node_1_reveal, exec_node_2_withdraw, initialize_contract, nop};\n  Protocol:\n    (((Environment.contract_initialized = false) and (Environment.part_B_is_done = false)) and ((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_reveal = enabled) and (Environment.part_B_is_done = false)): {exec_node_1_reveal, nop};\n    ((Environment.status_node_2_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_2_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nEvaluation\n  part_A_is_scheduled if (Environment.last_action = action_schedule_part_A);\n  part_B_is_scheduled if (Environment.last_action = action_schedule_part_B);\n  time_progresses_forever if ((Environment.time = 1) or (Environment.last_action = action_delay));\n  time_reaches_maximum if (Environment.time = 1);\n  timeout_1_has_expired if (Environment.time &gt;= 1);\n  part_A_is_done if (Environment.part_A_is_done = true);\n  part_B_is_done if (Environment.part_B_is_done = true);\n  private_secret_a_is_valid if (Agent_A.private_secret_a = valid);\n  private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid);\n  private_secret_a_is_not_committed if (Agent_A.private_secret_a = not_committed);\n  public_secret_a_is_committed if (Environment.public_secret_a = committed);\n  public_secret_a_is_not_committed if (Environment.public_secret_a = not_committed);\n  public_secret_a_is_valid if (Environment.public_secret_a = valid);\n  contract_is_initialized if (Environment.contract_initialized = true);\n  node_0_withdraw_is_disabled if (Environment.status_node_0_withdraw = disabled);\n  node_0_withdraw_is_enabled if (Environment.status_node_0_withdraw = enabled);\n  node_0_withdraw_is_executed if (Environment.status_node_0_withdraw = executed);\n  node_1_reveal_is_disabled if (Environment.status_node_1_reveal = disabled);\n  node_1_reveal_is_enabled if (Environment.status_node_1_reveal = enabled);\n  node_1_reveal_is_executed if (Environment.status_node_1_reveal = executed);\n  node_2_withdraw_is_disabled if (Environment.status_node_2_withdraw = disabled);\n  node_2_withdraw_is_enabled if (Environment.status_node_2_withdraw = enabled);\n  node_2_withdraw_is_executed if (Environment.status_node_2_withdraw = executed);\n  contract_funds_are_zero if (Environment.contract_funds = 0);\n  part_A_total_deposits_is_1 if (Environment.part_A_total_deposits = 1);\n  part_B_total_deposits_is_1 if (Environment.part_B_total_deposits = 1);\nend Evaluation\nInitStates\n  ((((((((((((((Environment.time = 0) and (Environment.part_A_is_done = false)) and (Environment.part_B_is_done = false)) and (Environment.contract_funds = 1)) and (Environment.part_A_total_deposits = 0)) and (Environment.part_B_total_deposits = 0)) and (Environment.public_secret_a = not_committed)) and (Agent_A.private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.status_node_0_withdraw = disabled)) and (Environment.status_node_1_reveal = disabled)) and (Environment.status_node_2_withdraw = disabled)) and (Environment.last_action = unset)) and (Agent_B.dummy = false));\nend InitStates\nGroups\n  Participants = {Agent_A, Agent_B};\n  Env = {Environment};\n  ParticipantsAndEnv = {Agent_A, Agent_B, Environment};\n  Agent_A = {Agent_A};\n  Agent_B = {Agent_B};\nend Groups\nFairness\n  part_A_is_scheduled;\n  part_B_is_scheduled;\n  time_progresses_forever;\nend Fairness\nFormulae\n  (AG ((contract_is_initialized) -&gt; ((&lt;Agent_A&gt;F(contract_funds_are_zero)))));\n  (AG ((contract_is_initialized) -&gt; ((&lt;Agent_B&gt;F(contract_funds_are_zero)))));\n  (AG ((private_secret_a_is_valid) -&gt; ((&lt;Agent_A&gt;F(part_A_total_deposits_is_1)))));\n  (AG (((private_secret_a_is_valid and ((!timeout_1_has_expired) and (!part_A_is_done)))) -&gt; ((&lt;Agent_A&gt;F(part_A_total_deposits_is_1)))));\n  (AG ((private_secret_a_is_invalid) -&gt; ((&lt;Agent_B&gt;F(part_B_total_deposits_is_1)))));\nend Formulae\n</code></pre> <p>By calling MCMAS with the command:</p> <pre><code>./mcmas -atlk 1  docs/01-timed-commitment/contract.ispl\n</code></pre> <p>We get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0 \n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law. \n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./tests/bin/mcmas -atlk 1 docs/01-timed-commitment/contract.ispl\n\ndocs/01-timed-commitment/contract.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (AG (contract_is_initialized -&gt; (&lt;Agent_A&gt;F contract_funds_are_zero))), is TRUE in the model\n  Formula number 2: (AG (contract_is_initialized -&gt; (&lt;Agent_B&gt;F contract_funds_are_zero))), is TRUE in the model\n  Formula number 3: (AG (private_secret_a_is_valid -&gt; (&lt;Agent_A&gt;F part_A_total_deposits_is_1))), is FALSE in the model\n  Formula number 4: (AG ((private_secret_a_is_valid &amp;&amp; ((! timeout_1_has_expired) &amp;&amp; (! part_A_is_done))) -&gt; (&lt;Agent_A&gt;F part_A_total_deposits_is_1))), is TRUE in the model\n  Formula number 5: (AG (private_secret_a_is_invalid -&gt; (&lt;Agent_B&gt;F part_B_total_deposits_is_1))), is TRUE in the model\ndone, 5 formulae successfully read and checked\nexecution time = 0.171\nnumber of reachable states = 161\nBDD memory in use = 10796592\n</code></pre> In\u00a0[5]: Copied! <pre>bitml_mutual_timed_commitment = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n\n(contract\n  (pre\n    (deposit \"A\" 1 \"txA@0\")\n    (deposit \"B\" 1 \"txB@0\")\n    (secret \"A\" a \"0001a\")\n    (secret \"B\" b \"0001b\")\n  )\n  (choice\n    (reveal (a) (choice\n      (reveal (b) (split\n        (1 -&gt; (withdraw \"A\"))\n        (1 -&gt; (withdraw \"B\"))\n      ))\n      (after 2 (withdraw \"A\"))\n    ))\n    (after 1 (withdraw \"B\"))\n  )\n)\n\"\"\"\n</pre> bitml_mutual_timed_commitment = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\")  (contract   (pre     (deposit \"A\" 1 \"txA@0\")     (deposit \"B\" 1 \"txB@0\")     (secret \"A\" a \"0001a\")     (secret \"B\" b \"0001b\")   )   (choice     (reveal (a) (choice       (reveal (b) (split         (1 -&gt; (withdraw \"A\"))         (1 -&gt; (withdraw \"B\"))       ))       (after 2 (withdraw \"A\"))     ))     (after 1 (withdraw \"B\"))   ) ) \"\"\" <p>We will verify the following ${\\rm ATL}$ specifications:</p> <ul> <li>If participant $A$ publishes an invalid commit, then he cannot recover his funds: $$AG((A.\\mathsf{private\\_secret\\_a} = \\mathsf{invalid}) \\to \\lnot \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits} \\ge 1))$$</li> <li>If timeout $t$ has expired and commitment for secret $a$ is invalid, then $B$ can recover his funds plus $A$'s penalty without revealing its secret $b$:: $$   AG(       (\\mathsf{public\\_secret\\_b} \\neq \\mathsf{valid} \\wedge A.\\mathsf{private\\_secret\\_a}=\\mathsf{invalid} \\wedge \\mathsf{time} \\ge t) \\to \\langle B \\rangle F (\\mathsf{public\\_secret\\_b} \\neq \\mathsf{valid} \\wedge \\mathsf{part\\_B\\_total\\_deposits} = 2)) $$</li> <li>If both participants commit to their secrets, then it is guaranteed that $B$ has always a strategy to take at least $1$ bitcoin: $$ AG((\\mathsf{contract\\_is\\_initialized} \\wedge \\mathsf{private\\_secret\\_b} = \\mathsf{valid} \\wedge \\mathsf{time} &lt; t) \\to \\langle B\\rangle F(\\mathsf{part\\_B\\_total\\_deposits}\\ge 1) ) $$</li> </ul> <p>The Python code to produce the ISPL is:</p> In\u00a0[6]: Copied! <pre># parse the contract\nparser = BitMLParser()\ncontract = parser(bitml_mutual_timed_commitment)\n\n# AG(contract_is_initialized -&gt; &lt;Agent_A&gt;F(contract_funds_are_zero))\nAGENT_A_CAN_ENFORCE_LIQUIDITY = AGFormula(\n    ImpliesFormula(\n        CONTRACT_IS_INITIALIZED,\n        DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO),\n    )\n)\n# AG(contract_is_initialized -&gt; &lt;Agent_B&gt;F(contract_funds_are_zero))\nAGENT_B_CAN_ENFORCE_LIQUIDITY = AGFormula(\n    ImpliesFormula(\n        CONTRACT_IS_INITIALIZED,\n        DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO),\n    )\n)\n# AG((private_secret_a_is_invalid) -&gt; (!&lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_1)))\nIF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        PRIVATE_SECRET_A_IS_INVALID,\n        NotFormula(\n            DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1)\n        )\n    )\n)\n\n# AG((!public_secret_b_is_valid and private_secret_a_is_invalid and timeout_1_has_expired) \n#     -&gt; &lt;Agent_B&gt;F(!public_secret_b_is_valid and part_B_total_deposits_is_2))\nIF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        AndFormula(\n            NotFormula(PUBLIC_SECRET_B_IS_VALID),\n            AndFormula(\n                PRIVATE_SECRET_A_IS_INVALID,\n                TIMEOUT_1_HAS_EXPIRED\n            )\n        ),\n        DiamondEventuallyFormula(AGENT_B, \n                                 AndFormula(\n                                     NotFormula(PUBLIC_SECRET_B_IS_VALID),\n                                     PART_B_TOTAL_DEPOSITS_IS_2\n                                 )\n        )\n    )\n)\n\n# AG((contract_is_initialized and private_secret_b_is_valid and !timeout_1_has_expired) \n#    -&gt; (&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_1)))\nIF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS = AGFormula(\n    ImpliesFormula(\n        AndFormula(\n            CONTRACT_IS_INITIALIZED,\n            AndFormula(\n                PRIVATE_SECRET_B_IS_VALID,\n                NotFormula(TIMEOUT_1_HAS_EXPIRED)\n            )\n        ),\n        DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1),\n    )\n)\n\nformulae = [\n    AGENT_A_CAN_ENFORCE_LIQUIDITY,\n    AGENT_B_CAN_ENFORCE_LIQUIDITY,\n    IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS,\n    IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS\n]\nevaluation_rules = [\n    CONTRACT_FUNDS_ARE_ZERO_ER,\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER,\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system = compiler.compile()\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\n_ = Path(\"02-mutual-timed-commitment/contract.ispl\").write_text(interpreted_system_str)\n</pre> # parse the contract parser = BitMLParser() contract = parser(bitml_mutual_timed_commitment)  # AG(contract_is_initialized -&gt; F(contract_funds_are_zero)) AGENT_A_CAN_ENFORCE_LIQUIDITY = AGFormula(     ImpliesFormula(         CONTRACT_IS_INITIALIZED,         DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO),     ) ) # AG(contract_is_initialized -&gt; F(contract_funds_are_zero)) AGENT_B_CAN_ENFORCE_LIQUIDITY = AGFormula(     ImpliesFormula(         CONTRACT_IS_INITIALIZED,         DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO),     ) ) # AG((private_secret_a_is_invalid) -&gt; (!F(part_A_total_deposits_is_at_least_1))) IF_AGENT_A_IS_DISHONEST_HE_DOES_NOT_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         PRIVATE_SECRET_A_IS_INVALID,         NotFormula(             DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_1)         )     ) )  # AG((!public_secret_b_is_valid and private_secret_a_is_invalid and timeout_1_has_expired)  #     -&gt; F(!public_secret_b_is_valid and part_B_total_deposits_is_2)) IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         AndFormula(             NotFormula(PUBLIC_SECRET_B_IS_VALID),             AndFormula(                 PRIVATE_SECRET_A_IS_INVALID,                 TIMEOUT_1_HAS_EXPIRED             )         ),         DiamondEventuallyFormula(AGENT_B,                                   AndFormula(                                      NotFormula(PUBLIC_SECRET_B_IS_VALID),                                      PART_B_TOTAL_DEPOSITS_IS_2                                  )         )     ) )  # AG((contract_is_initialized and private_secret_b_is_valid and !timeout_1_has_expired)  #    -&gt; (F(part_B_total_deposits_is_at_least_1))) IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS = AGFormula(     ImpliesFormula(         AndFormula(             CONTRACT_IS_INITIALIZED,             AndFormula(                 PRIVATE_SECRET_B_IS_VALID,                 NotFormula(TIMEOUT_1_HAS_EXPIRED)             )         ),         DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1),     ) )  formulae = [     AGENT_A_CAN_ENFORCE_LIQUIDITY,     AGENT_B_CAN_ENFORCE_LIQUIDITY,     IF_AGENT_A_IS_DISHONEST_AND_TIMEOUT_1_EXPIRED_THEN_B_CAN_RECOVER_FUNDS,     IF_BOTH_AGENT_A_AND_AGENT_B_HONEST_B_CAN_RECOVER_FUNDS ] evaluation_rules = [     CONTRACT_FUNDS_ARE_ZERO_ER,     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER, ] compiler = Compiler(     contract, formulae, evaluation_rules=evaluation_rules ) interpreted_system = compiler.compile() interpreted_system_str = interpreted_system_to_string(interpreted_system) _ = Path(\"02-mutual-timed-commitment/contract.ispl\").write_text(interpreted_system_str) <p>The output file <code>02-mutual-timed-commitment/contract.ispl</code> is pasted below:</p> <pre><code>Semantics=SingleAssignment;\nAgent Environment\n  Obsvars:\n    time: 0..2;\n    contract_funds: 0..2;\n    part_A_total_deposits: 0..2;\n    part_B_total_deposits: 0..2;\n    public_secret_a: {committed, not_committed, valid};\n    public_secret_b: {committed, not_committed, valid};\n    contract_initialized: boolean;\n    status_node_0_withdraw: {disabled, enabled, executed};\n    status_node_1_withdraw: {disabled, enabled, executed};\n    status_node_2_split: {disabled, enabled, executed};\n    status_node_3_reveal: {disabled, enabled, executed};\n    status_node_4_withdraw: {disabled, enabled, executed};\n    status_node_6_reveal: {disabled, enabled, executed};\n    status_node_7_withdraw: {disabled, enabled, executed};\n  end Obsvars\n  Vars:\n    part_A_is_done: boolean;\n    part_B_is_done: boolean;\n    last_action: {action_delay, action_schedule_part_A, action_schedule_part_B, unset};\n  end Vars\n\n  Actions = {delay, schedule_part_A, schedule_part_B};\n  Protocol:\n    (part_A_is_done = false): {schedule_part_A};\n    (part_B_is_done = false): {schedule_part_B};\n    Other: {delay};\n  end Protocol\n  Evolution:\n    part_A_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_B_is_done = false if ((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true)));\n    part_A_is_done = true if (((Action = schedule_part_A) and (Agent_A.Action = nop)) and (part_A_is_done = false));\n    part_B_is_done = true if (((Action = schedule_part_B) and (Agent_B.Action = nop)) and (part_B_is_done = false));\n    time = (time + 1) if (((Action = delay) and ((part_A_is_done = true) and (part_B_is_done = true))) and (time &lt; 2));\n    public_secret_a = committed if (((public_secret_a = not_committed) and ((Agent_A.Action = commit_valid_secret_a) or (Agent_A.Action = commit_invalid_secret_a))) and (Action = schedule_part_A));\n    public_secret_a = valid if (((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)) and (public_secret_a = committed));\n    public_secret_b = committed if (((public_secret_b = not_committed) and ((Agent_B.Action = commit_valid_secret_b) or (Agent_B.Action = commit_invalid_secret_b))) and (Action = schedule_part_B));\n    public_secret_b = valid if (((Agent_B.Action = reveal_secret_b) and (Action = schedule_part_B)) and (public_secret_b = committed));\n    contract_initialized = true if (((contract_initialized = false) and (((public_secret_a = committed) or (public_secret_a = valid)) and ((public_secret_b = committed) or (public_secret_b = valid)))) and (((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    status_node_0_withdraw = executed if (((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)));\n    status_node_0_withdraw = enabled if (((status_node_2_split = executed) or (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)))) and (status_node_0_withdraw = disabled));\n    contract_funds = (contract_funds - 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 1) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    status_node_1_withdraw = executed if (((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)));\n    status_node_1_withdraw = enabled if (((status_node_2_split = executed) or (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)))) and (status_node_1_withdraw = disabled));\n    status_node_2_split = executed if (((Agent_A.Action = exec_node_2_split) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_2_split) and (Action = schedule_part_B)));\n    status_node_2_split = enabled if (((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B)))) and (status_node_2_split = disabled));\n    status_node_3_reveal = executed if (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B)));\n    status_node_3_reveal = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_3_reveal = disabled)) and ((public_secret_b = valid) or ((Agent_B.Action = reveal_secret_b) and (Action = schedule_part_B)))) and (!((status_node_4_withdraw = executed) or (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))))));\n    status_node_3_reveal = disabled if ((status_node_4_withdraw = executed) or (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    status_node_4_withdraw = executed if (((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B)));\n    status_node_4_withdraw = enabled if (((((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)))) and (status_node_4_withdraw = disabled)) and ((time &gt;= 2) or ((time = 1) and (Action = delay)))) and (!((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))))));\n    status_node_4_withdraw = disabled if ((status_node_3_reveal = executed) or (((Agent_A.Action = exec_node_3_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_3_reveal) and (Action = schedule_part_B))));\n    status_node_6_reveal = executed if (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B)));\n    status_node_6_reveal = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_6_reveal = disabled)) and ((public_secret_a = valid) or ((Agent_A.Action = reveal_secret_a) and (Action = schedule_part_A)))) and (!((status_node_7_withdraw = executed) or (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B))))));\n    status_node_6_reveal = disabled if ((status_node_7_withdraw = executed) or (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 2) if (((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    status_node_7_withdraw = executed if (((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B)));\n    status_node_7_withdraw = enabled if (((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_7_withdraw = disabled)) and ((time &gt;= 1) or ((time = 0) and (Action = delay)))) and (!((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B))))));\n    status_node_7_withdraw = disabled if ((status_node_6_reveal = executed) or (((Agent_A.Action = exec_node_6_reveal) and (Action = schedule_part_A)) or ((Agent_B.Action = exec_node_6_reveal) and (Action = schedule_part_B))));\n    last_action = action_schedule_part_B if (Action = schedule_part_B);\n    last_action = action_schedule_part_A if (Action = schedule_part_A);\n    last_action = action_delay if (Action = delay);\n  end Evolution\nend Agent\n\nAgent Agent_A\n  Lobsvars = {part_A_is_done};\n  Vars:\n    private_secret_a: {invalid, not_committed, valid};\n  end Vars\n\n  Actions = {commit_invalid_secret_a, commit_valid_secret_a, exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_split, exec_node_3_reveal, exec_node_4_withdraw, exec_node_6_reveal, exec_node_7_withdraw, initialize_contract, nop, reveal_secret_a};\n  Protocol:\n    (((Environment.contract_initialized = false) and (private_secret_a = not_committed)) and (Environment.part_A_is_done = false)): {commit_invalid_secret_a, commit_valid_secret_a, nop};\n    (((private_secret_a = valid) and (Environment.public_secret_a = committed)) and (Environment.part_A_is_done = false)): {nop, reveal_secret_a};\n    (((Environment.contract_initialized = false) and (Environment.part_A_is_done = false)) and (((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid)) and ((Environment.public_secret_b = committed) or (Environment.public_secret_b = valid)))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_split = enabled) and (Environment.part_A_is_done = false)): {exec_node_2_split, nop};\n    ((Environment.status_node_3_reveal = enabled) and (Environment.part_A_is_done = false)): {exec_node_3_reveal, nop};\n    ((Environment.status_node_4_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_4_withdraw, nop};\n    ((Environment.status_node_6_reveal = enabled) and (Environment.part_A_is_done = false)): {exec_node_6_reveal, nop};\n    ((Environment.status_node_7_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_7_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    private_secret_a = valid if ((((Action = commit_valid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n    private_secret_a = invalid if ((((Action = commit_invalid_secret_a) and (private_secret_a = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_A));\n  end Evolution\nend Agent\nAgent Agent_B\n  Lobsvars = {part_B_is_done};\n  Vars:\n    private_secret_b: {invalid, not_committed, valid};\n  end Vars\n\n  Actions = {commit_invalid_secret_b, commit_valid_secret_b, exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_split, exec_node_3_reveal, exec_node_4_withdraw, exec_node_6_reveal, exec_node_7_withdraw, initialize_contract, nop, reveal_secret_b};\n  Protocol:\n    (((Environment.contract_initialized = false) and (private_secret_b = not_committed)) and (Environment.part_B_is_done = false)): {commit_invalid_secret_b, commit_valid_secret_b, nop};\n    (((private_secret_b = valid) and (Environment.public_secret_b = committed)) and (Environment.part_B_is_done = false)): {nop, reveal_secret_b};\n    (((Environment.contract_initialized = false) and (Environment.part_B_is_done = false)) and (((Environment.public_secret_a = committed) or (Environment.public_secret_a = valid)) and ((Environment.public_secret_b = committed) or (Environment.public_secret_b = valid)))): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_split = enabled) and (Environment.part_B_is_done = false)): {exec_node_2_split, nop};\n    ((Environment.status_node_3_reveal = enabled) and (Environment.part_B_is_done = false)): {exec_node_3_reveal, nop};\n    ((Environment.status_node_4_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_4_withdraw, nop};\n    ((Environment.status_node_6_reveal = enabled) and (Environment.part_B_is_done = false)): {exec_node_6_reveal, nop};\n    ((Environment.status_node_7_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_7_withdraw, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    private_secret_b = valid if ((((Action = commit_valid_secret_b) and (private_secret_b = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_B));\n    private_secret_b = invalid if ((((Action = commit_invalid_secret_b) and (private_secret_b = not_committed)) and (Environment.contract_initialized = false)) and (Environment.Action = schedule_part_B));\n  end Evolution\nend Agent\nEvaluation\n  part_A_is_scheduled if (Environment.last_action = action_schedule_part_A);\n  part_B_is_scheduled if (Environment.last_action = action_schedule_part_B);\n  time_progresses_forever if ((Environment.time = 2) or (Environment.last_action = action_delay));\n  time_reaches_maximum if (Environment.time = 2);\n  timeout_1_has_expired if (Environment.time &gt;= 1);\n  timeout_2_has_expired if (Environment.time &gt;= 2);\n  part_A_is_done if (Environment.part_A_is_done = true);\n  part_B_is_done if (Environment.part_B_is_done = true);\n  private_secret_a_is_valid if (Agent_A.private_secret_a = valid);\n  private_secret_a_is_invalid if (Agent_A.private_secret_a = invalid);\n  private_secret_a_is_not_committed if (Agent_A.private_secret_a = not_committed);\n  public_secret_a_is_committed if (Environment.public_secret_a = committed);\n  public_secret_a_is_not_committed if (Environment.public_secret_a = not_committed);\n  public_secret_a_is_valid if (Environment.public_secret_a = valid);\n  private_secret_b_is_valid if (Agent_B.private_secret_b = valid);\n  private_secret_b_is_invalid if (Agent_B.private_secret_b = invalid);\n  private_secret_b_is_not_committed if (Agent_B.private_secret_b = not_committed);\n  public_secret_b_is_committed if (Environment.public_secret_b = committed);\n  public_secret_b_is_not_committed if (Environment.public_secret_b = not_committed);\n  public_secret_b_is_valid if (Environment.public_secret_b = valid);\n  contract_is_initialized if (Environment.contract_initialized = true);\n  node_0_withdraw_is_disabled if (Environment.status_node_0_withdraw = disabled);\n  node_0_withdraw_is_enabled if (Environment.status_node_0_withdraw = enabled);\n  node_0_withdraw_is_executed if (Environment.status_node_0_withdraw = executed);\n  node_1_withdraw_is_disabled if (Environment.status_node_1_withdraw = disabled);\n  node_1_withdraw_is_enabled if (Environment.status_node_1_withdraw = enabled);\n  node_1_withdraw_is_executed if (Environment.status_node_1_withdraw = executed);\n  node_2_split_is_disabled if (Environment.status_node_2_split = disabled);\n  node_2_split_is_enabled if (Environment.status_node_2_split = enabled);\n  node_2_split_is_executed if (Environment.status_node_2_split = executed);\n  node_3_reveal_is_disabled if (Environment.status_node_3_reveal = disabled);\n  node_3_reveal_is_enabled if (Environment.status_node_3_reveal = enabled);\n  node_3_reveal_is_executed if (Environment.status_node_3_reveal = executed);\n  node_4_withdraw_is_disabled if (Environment.status_node_4_withdraw = disabled);\n  node_4_withdraw_is_enabled if (Environment.status_node_4_withdraw = enabled);\n  node_4_withdraw_is_executed if (Environment.status_node_4_withdraw = executed);\n  node_6_reveal_is_disabled if (Environment.status_node_6_reveal = disabled);\n  node_6_reveal_is_enabled if (Environment.status_node_6_reveal = enabled);\n  node_6_reveal_is_executed if (Environment.status_node_6_reveal = executed);\n  node_7_withdraw_is_disabled if (Environment.status_node_7_withdraw = disabled);\n  node_7_withdraw_is_enabled if (Environment.status_node_7_withdraw = enabled);\n  node_7_withdraw_is_executed if (Environment.status_node_7_withdraw = executed);\n  contract_funds_are_zero if (Environment.contract_funds = 0);\n  part_B_total_deposits_is_at_least_1 if (Environment.part_B_total_deposits &gt;= 1);\nend Evaluation\nInitStates\n  (((((((((((((((((((Environment.time = 0) and (Environment.part_A_is_done = false)) and (Environment.part_B_is_done = false)) and (Environment.contract_funds = 2)) and (Environment.part_A_total_deposits = 0)) and (Environment.part_B_total_deposits = 0)) and (Environment.public_secret_a = not_committed)) and (Environment.public_secret_b = not_committed)) and (Agent_A.private_secret_a = not_committed)) and (Agent_B.private_secret_b = not_committed)) and (Environment.contract_initialized = false)) and (Environment.status_node_0_withdraw = disabled)) and (Environment.status_node_1_withdraw = disabled)) and (Environment.status_node_2_split = disabled)) and (Environment.status_node_3_reveal = disabled)) and (Environment.status_node_4_withdraw = disabled)) and (Environment.status_node_6_reveal = disabled)) and (Environment.status_node_7_withdraw = disabled)) and (Environment.last_action = unset));\nend InitStates\nGroups\n  Participants = {Agent_A, Agent_B};\n  Env = {Environment};\n  ParticipantsAndEnv = {Agent_A, Agent_B, Environment};\n  Agent_A = {Agent_A};\n  Agent_B = {Agent_B};\nend Groups\nFairness\n  part_A_is_scheduled;\n  part_B_is_scheduled;\n  time_progresses_forever;\nend Fairness\nFormulae\n  (AG ((contract_is_initialized) -&gt; ((&lt;Agent_A&gt;F(contract_funds_are_zero)))));\n  (AG ((contract_is_initialized) -&gt; ((&lt;Agent_B&gt;F(contract_funds_are_zero)))));\n  (AG ((((!public_secret_b_is_valid) and (private_secret_a_is_invalid and timeout_1_has_expired))) -&gt; ((&lt;Agent_B&gt;F(((!public_secret_b_is_valid) and part_B_total_deposits_is_at_least_1))))));\n  (AG (((contract_is_initialized and (private_secret_b_is_valid and (!timeout_1_has_expired)))) -&gt; ((&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_1)))));\nend Formulae\n</code></pre> <p>By calling MCMAS with the command:</p> <pre><code>./mcmas -atlk 1  docs/02-mutual-timed-commitment/contract.ispl\n</code></pre> <p>We get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0 \n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law. \n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./tests/bin/mcmas -atlk 1 docs/02-mutual-timed-commitment/contract.ispl\n\ndocs/02-mutual-timed-commitment/contract.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (AG (contract_is_initialized -&gt; (&lt;Agent_A&gt;F contract_funds_are_zero))), is TRUE in the model\n  Formula number 2: (AG (contract_is_initialized -&gt; (&lt;Agent_B&gt;F contract_funds_are_zero))), is TRUE in the model\n  Formula number 3: (AG (((! public_secret_b_is_valid) &amp;&amp; (private_secret_a_is_invalid &amp;&amp; timeout_1_has_expired)) -&gt; (&lt;Agent_B&gt;F ((! public_secret_b_is_valid) &amp;&amp; part_B_total_deposits_is_at_least_1)))), is TRUE in the model\n  Formula number 4: (AG ((contract_is_initialized &amp;&amp; (private_secret_b_is_valid &amp;&amp; (! timeout_1_has_expired))) -&gt; (&lt;Agent_B&gt;F part_B_total_deposits_is_at_least_1))), is TRUE in the model\ndone, 4 formulae successfully read and checked\nexecution time = 1.537\nnumber of reachable states = 1659\nBDD memory in use = 14566192\n</code></pre> <p>By replacing <code>after 2</code> with <code>after 1</code> and repeating the compilation and the verification, you get that Formula 4 is FALSE.</p> In\u00a0[7]: Copied! <pre>bitml_escrow = \"\"\"\n#lang bitml\n\n(participant \"A\" \"0a\")\n(participant \"B\" \"0b\")\n(participant \"M\" \"0e\")\n\n(contract\n  (pre\n    (deposit \"A\" 10 \"txA@0\")\n  )\n  (choice\n    (auth \"A\" (withdraw \"B\"))\n    (auth \"B\" (withdraw \"A\"))\n    (auth \"A\" (split\n      (1 -&gt; (withdraw \"M\"))\n      (9 -&gt; (choice\n        (auth \"M\" (withdraw \"A\"))\n        (auth \"M\" (withdraw \"B\"))\n      ))\n    ))\n    (auth \"B\" (split\n      (1 -&gt; (withdraw \"M\"))\n      (9 -&gt; (choice\n        (auth \"M\" (withdraw \"A\"))\n        (auth \"M\" (withdraw \"B\"))\n      ))\n    ))\n  )\n)\n\"\"\"\n</pre> bitml_escrow = \"\"\" #lang bitml  (participant \"A\" \"0a\") (participant \"B\" \"0b\") (participant \"M\" \"0e\")  (contract   (pre     (deposit \"A\" 10 \"txA@0\")   )   (choice     (auth \"A\" (withdraw \"B\"))     (auth \"B\" (withdraw \"A\"))     (auth \"A\" (split       (1 -&gt; (withdraw \"M\"))       (9 -&gt; (choice         (auth \"M\" (withdraw \"A\"))         (auth \"M\" (withdraw \"B\"))       ))     ))     (auth \"B\" (split       (1 -&gt; (withdraw \"M\"))       (9 -&gt; (choice         (auth \"M\" (withdraw \"A\"))         (auth \"M\" (withdraw \"B\"))       ))     ))   ) ) \"\"\" <p>We will verify the following ${\\rm ATL}$ specifications:</p> <ul> <li><p>The contract is not liquid from $A$'s perspective, i.e. the following specification does not hold: $$ \\langle A \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>Similarly for $B$ and $M$:</p> </li> </ul> <p>$$ \\langle B \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>$$ \\langle M \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <ul> <li>However, if we take any subset of at least two players, the contract becomes liquid:</li> </ul> <p>$$ \\langle A, B \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>$$ \\langle A, M \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>$$ \\langle B, M \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <ul> <li>$A$ (resp. $B$) can guarantee that $B$ (resp. $A$) gets at least $9$ bitcoin (false):</li> </ul> <p>$$ \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits\\_is\\_at\\_least\\_9}) $$</p> <p>$$ \\langle A \\rangle F (\\mathsf{part\\_A\\_total\\_deposits\\_is\\_at\\_least\\_9}) $$</p> <ul> <li>If the <code>Resolve</code> branch has been taken, then the mediator $M$ gets its commission (true)</li> </ul> <p>$$  AG((\\mathsf{status\\_node\\_6\\_split\\_is\\_executed} \\vee \\mathsf{status\\_node\\_11\\_split\\_is\\_executed}) \\to \\langle M \\rangle F (\\mathsf{part\\_M\\_total\\_deposits\\_is\\_at\\_least\\_1}))  $$</p> <ul> <li>If the <code>Resolve</code> branch has been taken, and no withdraw has been already authorized, then the mediator $M$ is able to both reward $A$ and $B$ (true):</li> </ul> <p>$$ \\begin{aligned} &amp;AG((\\\\ &amp;    \\qquad (\\mathsf{status\\_node\\_6\\_split\\_is\\_executed} \\vee \\mathsf{status\\_node\\_11\\_split\\_is\\_executed})\\\\ &amp;    \\qquad \\wedge \\lnot\\mathsf{node\\_3\\_withdraw\\_is\\_authorized\\_by\\_M}\\\\ &amp;    \\qquad \\wedge \\lnot\\mathsf{node\\_4\\_withdraw\\_is\\_authorized\\_by\\_M}\\\\   &amp;    \\qquad \\wedge \\lnot\\mathsf{node\\_8\\_withdraw\\_is\\_authorized\\_by\\_M}\\\\ &amp;    \\qquad \\wedge \\lnot\\mathsf{node\\_9\\_withdraw\\_is\\_authorized\\_by\\_M})\\\\ &amp;    \\qquad \\to (\\\\ &amp;    \\qquad\\qquad\\quad  \\langle M\\rangle F (\\mathsf{part\\_A\\_total\\_deposits\\_is\\_at\\_least\\_9}) \\\\ &amp;    \\qquad\\qquad\\wedge \\langle M\\rangle F (\\mathsf{part\\_B\\_total\\_deposits\\_is\\_at\\_least\\_9}) \\\\ )) \\end{aligned} $$</p> <p>The Python code to produce the ISPL is:</p> In\u00a0[8]: Copied! <pre># parse the contract\nparser = BitMLParser()\ncontract = parser(bitml_escrow)\n\nAGENT_A_AND_AGENT_B = \"Agent_A__Agent_B\"\nAGENT_A_AND_AGENT_M = \"Agent_A__Agent_M\"\nAGENT_B_AND_AGENT_M = \"Agent_B__Agent_M\"\n\n# &lt;Agent_A&gt;F(contract_funds_are_zero)\nAGENT_A_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_B&gt;F(contract_funds_are_zero)\nAGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_M&gt;F(contract_funds_are_zero)\nAGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_M, CONTRACT_FUNDS_ARE_ZERO)\n\n# &lt;Agent_A,Agent_B&gt;F(contract_funds_are_zero)\nAGENT_A_AND_AGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A_AND_AGENT_B, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_A,Agent_M&gt;F(contract_funds_are_zero)\nAGENT_A_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A_AND_AGENT_M, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_B,Agent_M&gt;F(contract_funds_are_zero)\nAGENT_B_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B_AND_AGENT_M, CONTRACT_FUNDS_ARE_ZERO)\n\n# &lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_9)\nAGENT_A_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9)\n# &lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_9)\nAGENT_B_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9)\n\n# AG((status_node_6_split_is_executed | status_node_11_split_is_executed) \n#     -&gt; &lt;M&gt;F(part_M_total_deposits_is_at_least_1))\nVAR_PART_M_TOTAL_DEPOSITS = \"part_M_total_deposits\"\nPART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_M_total_deposits_is_at_least_1\"\nPART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP)\nPART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(\n    PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,\n    GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_M_TOTAL_DEPOSITS), IntAtom(1))\n)\nIF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GET_COMMISSION = AGFormula(\n    ImpliesFormula(\n        AtomicFormula(\"node_6_split_is_executed\") | AtomicFormula(\"node_11_split_is_executed\"),\n        DiamondEventuallyFormula(AGENT_M, PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1),\n    )\n)\n\n# AG( ( (status_node_6_split_is_executed | status_node_11_split_is_executed)\n#       &amp; !node_3_withdraw_is_authorized_by_M \n#       &amp; !node_4_withdraw_is_authorized_by_M \n#       &amp; !node_8_withdraw_is_authorized_by_M \n#       &amp; !node_9_withdraw_is_authorized_by_M)\n#       -&gt; (&lt;M&gt;F(part_A_total_deposits_is_at_least_9)\n#           &lt;M&gt;F(part_B_total_deposits_is_at_least_9))\n# )\nIF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GIVE_FUNDS_TO_A_OR_B = AGFormula(\n    ImpliesFormula(\n        (AtomicFormula(\"node_6_split_is_executed\") | AtomicFormula(\"node_11_split_is_executed\"))\n        &amp; ~AtomicFormula(\"node_3_withdraw_is_authorized_by_M\")\n        &amp; ~AtomicFormula(\"node_4_withdraw_is_authorized_by_M\")\n        &amp; ~AtomicFormula(\"node_8_withdraw_is_authorized_by_M\")\n        &amp; ~AtomicFormula(\"node_9_withdraw_is_authorized_by_M\"),\n        AndFormula(\n            DiamondEventuallyFormula(AGENT_M, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9),\n            DiamondEventuallyFormula(AGENT_M, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9),\n        )\n    )\n)\n\nformulae = [\n    AGENT_A_CAN_ENFORCE_LIQUIDITY,\n    AGENT_B_CAN_ENFORCE_LIQUIDITY,\n    AGENT_M_CAN_ENFORCE_LIQUIDITY,\n    AGENT_A_AND_AGENT_B_CAN_ENFORCE_LIQUIDITY,\n    AGENT_A_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY,\n    AGENT_B_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY,\n    AGENT_A_CAN_GET_AT_LEAST_9,\n    AGENT_B_CAN_GET_AT_LEAST_9,\n    IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GET_COMMISSION,\n    IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GIVE_FUNDS_TO_A_OR_B\n]\nevaluation_rules = [\n    CONTRACT_FUNDS_ARE_ZERO_ER,\n    PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER,\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER,\n    PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system = compiler.compile()\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\n_ = Path(\"03-escrow/contract.ispl\").write_text(interpreted_system_str)\n</pre> # parse the contract parser = BitMLParser() contract = parser(bitml_escrow)  AGENT_A_AND_AGENT_B = \"Agent_A__Agent_B\" AGENT_A_AND_AGENT_M = \"Agent_A__Agent_M\" AGENT_B_AND_AGENT_M = \"Agent_B__Agent_M\"  # F(contract_funds_are_zero) AGENT_A_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_M, CONTRACT_FUNDS_ARE_ZERO)  # F(contract_funds_are_zero) AGENT_A_AND_AGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A_AND_AGENT_B, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_A_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A_AND_AGENT_M, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_B_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B_AND_AGENT_M, CONTRACT_FUNDS_ARE_ZERO)  # F(part_A_total_deposits_is_at_least_9) AGENT_A_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9) # F(part_A_total_deposits_is_at_least_9) AGENT_B_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9)  # AG((status_node_6_split_is_executed | status_node_11_split_is_executed)  #     -&gt; F(part_M_total_deposits_is_at_least_1)) VAR_PART_M_TOTAL_DEPOSITS = \"part_M_total_deposits\" PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP = \"part_M_total_deposits_is_at_least_1\" PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1 = AtomicFormula(PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP) PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER = EvaluationRule(     PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_PROP,     GreaterThanOrEqual(EnvironmentIdAtom(VAR_PART_M_TOTAL_DEPOSITS), IntAtom(1)) ) IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GET_COMMISSION = AGFormula(     ImpliesFormula(         AtomicFormula(\"node_6_split_is_executed\") | AtomicFormula(\"node_11_split_is_executed\"),         DiamondEventuallyFormula(AGENT_M, PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1),     ) )  # AG( ( (status_node_6_split_is_executed | status_node_11_split_is_executed) #       &amp; !node_3_withdraw_is_authorized_by_M  #       &amp; !node_4_withdraw_is_authorized_by_M  #       &amp; !node_8_withdraw_is_authorized_by_M  #       &amp; !node_9_withdraw_is_authorized_by_M) #       -&gt; (F(part_A_total_deposits_is_at_least_9) #           F(part_B_total_deposits_is_at_least_9)) # ) IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GIVE_FUNDS_TO_A_OR_B = AGFormula(     ImpliesFormula(         (AtomicFormula(\"node_6_split_is_executed\") | AtomicFormula(\"node_11_split_is_executed\"))         &amp; ~AtomicFormula(\"node_3_withdraw_is_authorized_by_M\")         &amp; ~AtomicFormula(\"node_4_withdraw_is_authorized_by_M\")         &amp; ~AtomicFormula(\"node_8_withdraw_is_authorized_by_M\")         &amp; ~AtomicFormula(\"node_9_withdraw_is_authorized_by_M\"),         AndFormula(             DiamondEventuallyFormula(AGENT_M, PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9),             DiamondEventuallyFormula(AGENT_M, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9),         )     ) )  formulae = [     AGENT_A_CAN_ENFORCE_LIQUIDITY,     AGENT_B_CAN_ENFORCE_LIQUIDITY,     AGENT_M_CAN_ENFORCE_LIQUIDITY,     AGENT_A_AND_AGENT_B_CAN_ENFORCE_LIQUIDITY,     AGENT_A_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY,     AGENT_B_AND_AGENT_M_CAN_ENFORCE_LIQUIDITY,     AGENT_A_CAN_GET_AT_LEAST_9,     AGENT_B_CAN_GET_AT_LEAST_9,     IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GET_COMMISSION,     IF_RESOLVE_BRANCH_TAKEN_THEN_MEDIATOR_CAN_GIVE_FUNDS_TO_A_OR_B ] evaluation_rules = [     CONTRACT_FUNDS_ARE_ZERO_ER,     PART_A_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER,     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER,     PART_M_TOTAL_DEPOSITS_IS_AT_LEAST_1_ER ] compiler = Compiler(     contract, formulae, evaluation_rules=evaluation_rules ) interpreted_system = compiler.compile() interpreted_system_str = interpreted_system_to_string(interpreted_system) _ = Path(\"03-escrow/contract.ispl\").write_text(interpreted_system_str) <p>The output file <code>03-escrow/contract.ispl</code> is pasted below:</p> <pre><code>Semantics=SingleAssignment;\nAgent Environment\n  Obsvars:\n    contract_funds: 0..10;\n    part_A_total_deposits: 0..10;\n    part_M_total_deposits: 0..10;\n    part_B_total_deposits: 0..10;\n    contract_initialized: boolean;\n    node_0_withdraw_authorized_by_part_A: boolean;\n    status_node_0_withdraw: {disabled, enabled, executed};\n    node_1_withdraw_authorized_by_part_B: boolean;\n    status_node_1_withdraw: {disabled, enabled, executed};\n    status_node_2_withdraw: {disabled, enabled, executed};\n    node_3_withdraw_authorized_by_part_M: boolean;\n    status_node_3_withdraw: {disabled, enabled, executed};\n    node_4_withdraw_authorized_by_part_M: boolean;\n    status_node_4_withdraw: {disabled, enabled, executed};\n    node_6_split_authorized_by_part_A: boolean;\n    status_node_6_split: {disabled, enabled, executed};\n    status_node_7_withdraw: {disabled, enabled, executed};\n    node_8_withdraw_authorized_by_part_M: boolean;\n    status_node_8_withdraw: {disabled, enabled, executed};\n    node_9_withdraw_authorized_by_part_M: boolean;\n    status_node_9_withdraw: {disabled, enabled, executed};\n    node_11_split_authorized_by_part_B: boolean;\n    status_node_11_split: {disabled, enabled, executed};\n  end Obsvars\n  Vars:\n    last_action: {action_schedule_part_A, action_schedule_part_B, action_schedule_part_M, unset};\n  end Vars\n\n  Actions = {schedule_part_A, schedule_part_B, schedule_part_M};\n  Protocol:\n    Other: {schedule_part_A, schedule_part_B, schedule_part_M};\n  end Protocol\n  Evolution:\n    contract_initialized = true if ((contract_initialized = false) and ((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_M) and (Agent_M.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))));\n    contract_funds = (contract_funds - 10) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_0_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 10) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_0_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    status_node_0_withdraw = executed if ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)));\n    node_0_withdraw_authorized_by_part_A = true if ((Agent_A.Action = authorize_node_0_withdraw) and (Action = schedule_part_A));\n    status_node_0_withdraw = enabled if ((((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_M) and (Agent_M.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_0_withdraw = disabled)) and ((node_0_withdraw_authorized_by_part_A = true) or ((Agent_A.Action = authorize_node_0_withdraw) and (Action = schedule_part_A)))) and (((!((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B))))) and (!((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))))) and (!((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))))));\n    status_node_0_withdraw = disabled if ((((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)))) or ((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B))))) or ((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))));\n    contract_funds = (contract_funds - 10) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_1_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 10) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_1_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    status_node_1_withdraw = executed if ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)));\n    node_1_withdraw_authorized_by_part_B = true if ((Agent_B.Action = authorize_node_1_withdraw) and (Action = schedule_part_B));\n    status_node_1_withdraw = enabled if ((((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_M) and (Agent_M.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_1_withdraw = disabled)) and ((node_1_withdraw_authorized_by_part_B = true) or ((Agent_B.Action = authorize_node_1_withdraw) and (Action = schedule_part_B)))) and (((!((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B))))) and (!((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))))) and (!((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))))));\n    status_node_1_withdraw = disabled if ((((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)))) or ((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B))))) or ((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))));\n    contract_funds = (contract_funds - 1) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_2_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    part_M_total_deposits = (part_M_total_deposits + 1) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_2_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    status_node_2_withdraw = executed if ((((Agent_A.Action = exec_node_2_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_2_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_2_withdraw) and (Action = schedule_part_B)));\n    status_node_2_withdraw = enabled if (((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))) and (status_node_2_withdraw = disabled));\n    contract_funds = (contract_funds - 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_3_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_3_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_3_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_3_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_3_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_3_withdraw)));\n    status_node_3_withdraw = executed if ((((Agent_A.Action = exec_node_3_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_3_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_3_withdraw) and (Action = schedule_part_B)));\n    node_3_withdraw_authorized_by_part_M = true if ((Agent_M.Action = authorize_node_3_withdraw) and (Action = schedule_part_M));\n    status_node_3_withdraw = enabled if (((((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))) and (status_node_3_withdraw = disabled)) and ((node_3_withdraw_authorized_by_part_M = true) or ((Agent_M.Action = authorize_node_3_withdraw) and (Action = schedule_part_M)))) and (!((status_node_4_withdraw = executed) or ((((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_4_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))))));\n    status_node_3_withdraw = disabled if ((status_node_4_withdraw = executed) or ((((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_4_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_4_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_4_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_withdraw)));\n    status_node_4_withdraw = executed if ((((Agent_A.Action = exec_node_4_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_4_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_4_withdraw) and (Action = schedule_part_B)));\n    node_4_withdraw_authorized_by_part_M = true if ((Agent_M.Action = authorize_node_4_withdraw) and (Action = schedule_part_M));\n    status_node_4_withdraw = enabled if (((((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))) and (status_node_4_withdraw = disabled)) and ((node_4_withdraw_authorized_by_part_M = true) or ((Agent_M.Action = authorize_node_4_withdraw) and (Action = schedule_part_M)))) and (!((status_node_3_withdraw = executed) or ((((Agent_A.Action = exec_node_3_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_3_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_3_withdraw) and (Action = schedule_part_B))))));\n    status_node_4_withdraw = disabled if ((status_node_3_withdraw = executed) or ((((Agent_A.Action = exec_node_3_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_3_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_3_withdraw) and (Action = schedule_part_B))));\n    status_node_6_split = executed if ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)));\n    node_6_split_authorized_by_part_A = true if ((Agent_A.Action = authorize_node_6_split) and (Action = schedule_part_A));\n    status_node_6_split = enabled if ((((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_M) and (Agent_M.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_6_split = disabled)) and ((node_6_split_authorized_by_part_A = true) or ((Agent_A.Action = authorize_node_6_split) and (Action = schedule_part_A)))) and (((!((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B))))) and (!((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)))))) and (!((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))))));\n    status_node_6_split = disabled if ((((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)))) or ((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B))))) or ((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))));\n    contract_funds = (contract_funds - 1) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_7_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    part_M_total_deposits = (part_M_total_deposits + 1) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_7_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_7_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_7_withdraw)));\n    status_node_7_withdraw = executed if ((((Agent_A.Action = exec_node_7_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_7_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_7_withdraw) and (Action = schedule_part_B)));\n    status_node_7_withdraw = enabled if (((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))) and (status_node_7_withdraw = disabled));\n    contract_funds = (contract_funds - 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_8_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_8_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_8_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_8_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_8_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_8_withdraw)));\n    status_node_8_withdraw = executed if ((((Agent_A.Action = exec_node_8_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_8_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_8_withdraw) and (Action = schedule_part_B)));\n    node_8_withdraw_authorized_by_part_M = true if ((Agent_M.Action = authorize_node_8_withdraw) and (Action = schedule_part_M));\n    status_node_8_withdraw = enabled if (((((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))) and (status_node_8_withdraw = disabled)) and ((node_8_withdraw_authorized_by_part_M = true) or ((Agent_M.Action = authorize_node_8_withdraw) and (Action = schedule_part_M)))) and (!((status_node_9_withdraw = executed) or ((((Agent_A.Action = exec_node_9_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_9_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_9_withdraw) and (Action = schedule_part_B))))));\n    status_node_8_withdraw = disabled if ((status_node_9_withdraw = executed) or ((((Agent_A.Action = exec_node_9_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_9_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_9_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_9_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_9_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_9_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 9) if ((((Action = schedule_part_A) and (Agent_A.Action = exec_node_9_withdraw)) or ((Action = schedule_part_M) and (Agent_M.Action = exec_node_9_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_9_withdraw)));\n    status_node_9_withdraw = executed if ((((Agent_A.Action = exec_node_9_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_9_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_9_withdraw) and (Action = schedule_part_B)));\n    node_9_withdraw_authorized_by_part_M = true if ((Agent_M.Action = authorize_node_9_withdraw) and (Action = schedule_part_M));\n    status_node_9_withdraw = enabled if (((((status_node_11_split = executed) or ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)))) and (status_node_9_withdraw = disabled)) and ((node_9_withdraw_authorized_by_part_M = true) or ((Agent_M.Action = authorize_node_9_withdraw) and (Action = schedule_part_M)))) and (!((status_node_8_withdraw = executed) or ((((Agent_A.Action = exec_node_8_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_8_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_8_withdraw) and (Action = schedule_part_B))))));\n    status_node_9_withdraw = disabled if ((status_node_8_withdraw = executed) or ((((Agent_A.Action = exec_node_8_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_8_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_8_withdraw) and (Action = schedule_part_B))));\n    status_node_11_split = executed if ((((Agent_A.Action = exec_node_11_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_11_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_11_split) and (Action = schedule_part_B)));\n    node_11_split_authorized_by_part_B = true if ((Agent_B.Action = authorize_node_11_split) and (Action = schedule_part_B));\n    status_node_11_split = enabled if ((((((((Action = schedule_part_A) and (Agent_A.Action = initialize_contract)) or ((Action = schedule_part_M) and (Agent_M.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_11_split = disabled)) and ((node_11_split_authorized_by_part_B = true) or ((Agent_B.Action = authorize_node_11_split) and (Action = schedule_part_B)))) and (((!((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B))))) and (!((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)))))) and (!((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))))));\n    status_node_11_split = disabled if ((((status_node_0_withdraw = executed) or ((((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_0_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)))) or ((status_node_1_withdraw = executed) or ((((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_1_withdraw) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B))))) or ((status_node_6_split = executed) or ((((Agent_A.Action = exec_node_6_split) and (Action = schedule_part_A)) or ((Agent_M.Action = exec_node_6_split) and (Action = schedule_part_M))) or ((Agent_B.Action = exec_node_6_split) and (Action = schedule_part_B)))));\n    last_action = action_schedule_part_B if (Action = schedule_part_B);\n    last_action = action_schedule_part_A if (Action = schedule_part_A);\n    last_action = action_schedule_part_M if (Action = schedule_part_M);\n  end Evolution\nend Agent\n\nAgent Agent_A\n  Lobsvars = {};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {authorize_node_0_withdraw, authorize_node_6_split, exec_node_0_withdraw, exec_node_11_split, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_withdraw, exec_node_4_withdraw, exec_node_6_split, exec_node_7_withdraw, exec_node_8_withdraw, exec_node_9_withdraw, initialize_contract, nop};\n  Protocol:\n    (Environment.contract_initialized = false): {initialize_contract, nop};\n    (Environment.status_node_0_withdraw = enabled): {exec_node_0_withdraw, nop};\n    ((Environment.node_0_withdraw_authorized_by_part_A = false) and (Environment.contract_initialized = true)): {authorize_node_0_withdraw, nop};\n    (Environment.status_node_1_withdraw = enabled): {exec_node_1_withdraw, nop};\n    (Environment.status_node_2_withdraw = enabled): {exec_node_2_withdraw, nop};\n    (Environment.status_node_3_withdraw = enabled): {exec_node_3_withdraw, nop};\n    (Environment.status_node_4_withdraw = enabled): {exec_node_4_withdraw, nop};\n    (Environment.status_node_6_split = enabled): {exec_node_6_split, nop};\n    ((Environment.node_6_split_authorized_by_part_A = false) and (Environment.contract_initialized = true)): {authorize_node_6_split, nop};\n    (Environment.status_node_7_withdraw = enabled): {exec_node_7_withdraw, nop};\n    (Environment.status_node_8_withdraw = enabled): {exec_node_8_withdraw, nop};\n    (Environment.status_node_9_withdraw = enabled): {exec_node_9_withdraw, nop};\n    (Environment.status_node_11_split = enabled): {exec_node_11_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nAgent Agent_M\n  Lobsvars = {};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {authorize_node_3_withdraw, authorize_node_4_withdraw, authorize_node_8_withdraw, authorize_node_9_withdraw, exec_node_0_withdraw, exec_node_11_split, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_withdraw, exec_node_4_withdraw, exec_node_6_split, exec_node_7_withdraw, exec_node_8_withdraw, exec_node_9_withdraw, initialize_contract, nop};\n  Protocol:\n    (Environment.contract_initialized = false): {initialize_contract, nop};\n    (Environment.status_node_0_withdraw = enabled): {exec_node_0_withdraw, nop};\n    (Environment.status_node_1_withdraw = enabled): {exec_node_1_withdraw, nop};\n    (Environment.status_node_2_withdraw = enabled): {exec_node_2_withdraw, nop};\n    (Environment.status_node_3_withdraw = enabled): {exec_node_3_withdraw, nop};\n    ((Environment.node_3_withdraw_authorized_by_part_M = false) and (Environment.contract_initialized = true)): {authorize_node_3_withdraw, nop};\n    (Environment.status_node_4_withdraw = enabled): {exec_node_4_withdraw, nop};\n    ((Environment.node_4_withdraw_authorized_by_part_M = false) and (Environment.contract_initialized = true)): {authorize_node_4_withdraw, nop};\n    (Environment.status_node_6_split = enabled): {exec_node_6_split, nop};\n    (Environment.status_node_7_withdraw = enabled): {exec_node_7_withdraw, nop};\n    (Environment.status_node_8_withdraw = enabled): {exec_node_8_withdraw, nop};\n    ((Environment.node_8_withdraw_authorized_by_part_M = false) and (Environment.contract_initialized = true)): {authorize_node_8_withdraw, nop};\n    (Environment.status_node_9_withdraw = enabled): {exec_node_9_withdraw, nop};\n    ((Environment.node_9_withdraw_authorized_by_part_M = false) and (Environment.contract_initialized = true)): {authorize_node_9_withdraw, nop};\n    (Environment.status_node_11_split = enabled): {exec_node_11_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nAgent Agent_B\n  Lobsvars = {};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {authorize_node_11_split, authorize_node_1_withdraw, exec_node_0_withdraw, exec_node_11_split, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_withdraw, exec_node_4_withdraw, exec_node_6_split, exec_node_7_withdraw, exec_node_8_withdraw, exec_node_9_withdraw, initialize_contract, nop};\n  Protocol:\n    (Environment.contract_initialized = false): {initialize_contract, nop};\n    (Environment.status_node_0_withdraw = enabled): {exec_node_0_withdraw, nop};\n    (Environment.status_node_1_withdraw = enabled): {exec_node_1_withdraw, nop};\n    ((Environment.node_1_withdraw_authorized_by_part_B = false) and (Environment.contract_initialized = true)): {authorize_node_1_withdraw, nop};\n    (Environment.status_node_2_withdraw = enabled): {exec_node_2_withdraw, nop};\n    (Environment.status_node_3_withdraw = enabled): {exec_node_3_withdraw, nop};\n    (Environment.status_node_4_withdraw = enabled): {exec_node_4_withdraw, nop};\n    (Environment.status_node_6_split = enabled): {exec_node_6_split, nop};\n    (Environment.status_node_7_withdraw = enabled): {exec_node_7_withdraw, nop};\n    (Environment.status_node_8_withdraw = enabled): {exec_node_8_withdraw, nop};\n    (Environment.status_node_9_withdraw = enabled): {exec_node_9_withdraw, nop};\n    (Environment.status_node_11_split = enabled): {exec_node_11_split, nop};\n    ((Environment.node_11_split_authorized_by_part_B = false) and (Environment.contract_initialized = true)): {authorize_node_11_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nEvaluation\n  part_A_is_scheduled if (Environment.last_action = action_schedule_part_A);\n  part_M_is_scheduled if (Environment.last_action = action_schedule_part_M);\n  part_B_is_scheduled if (Environment.last_action = action_schedule_part_B);\n  contract_is_initialized if (Environment.contract_initialized = true);\n  node_0_withdraw_is_disabled if (Environment.status_node_0_withdraw = disabled);\n  node_0_withdraw_is_enabled if (Environment.status_node_0_withdraw = enabled);\n  node_0_withdraw_is_executed if (Environment.status_node_0_withdraw = executed);\n  node_0_withdraw_is_authorized_by_A if (Environment.node_0_withdraw_authorized_by_part_A = true);\n  node_1_withdraw_is_disabled if (Environment.status_node_1_withdraw = disabled);\n  node_1_withdraw_is_enabled if (Environment.status_node_1_withdraw = enabled);\n  node_1_withdraw_is_executed if (Environment.status_node_1_withdraw = executed);\n  node_1_withdraw_is_authorized_by_B if (Environment.node_1_withdraw_authorized_by_part_B = true);\n  node_2_withdraw_is_disabled if (Environment.status_node_2_withdraw = disabled);\n  node_2_withdraw_is_enabled if (Environment.status_node_2_withdraw = enabled);\n  node_2_withdraw_is_executed if (Environment.status_node_2_withdraw = executed);\n  node_3_withdraw_is_disabled if (Environment.status_node_3_withdraw = disabled);\n  node_3_withdraw_is_enabled if (Environment.status_node_3_withdraw = enabled);\n  node_3_withdraw_is_executed if (Environment.status_node_3_withdraw = executed);\n  node_3_withdraw_is_authorized_by_M if (Environment.node_3_withdraw_authorized_by_part_M = true);\n  node_4_withdraw_is_disabled if (Environment.status_node_4_withdraw = disabled);\n  node_4_withdraw_is_enabled if (Environment.status_node_4_withdraw = enabled);\n  node_4_withdraw_is_executed if (Environment.status_node_4_withdraw = executed);\n  node_4_withdraw_is_authorized_by_M if (Environment.node_4_withdraw_authorized_by_part_M = true);\n  node_6_split_is_disabled if (Environment.status_node_6_split = disabled);\n  node_6_split_is_enabled if (Environment.status_node_6_split = enabled);\n  node_6_split_is_executed if (Environment.status_node_6_split = executed);\n  node_6_split_is_authorized_by_A if (Environment.node_6_split_authorized_by_part_A = true);\n  node_7_withdraw_is_disabled if (Environment.status_node_7_withdraw = disabled);\n  node_7_withdraw_is_enabled if (Environment.status_node_7_withdraw = enabled);\n  node_7_withdraw_is_executed if (Environment.status_node_7_withdraw = executed);\n  node_8_withdraw_is_disabled if (Environment.status_node_8_withdraw = disabled);\n  node_8_withdraw_is_enabled if (Environment.status_node_8_withdraw = enabled);\n  node_8_withdraw_is_executed if (Environment.status_node_8_withdraw = executed);\n  node_8_withdraw_is_authorized_by_M if (Environment.node_8_withdraw_authorized_by_part_M = true);\n  node_9_withdraw_is_disabled if (Environment.status_node_9_withdraw = disabled);\n  node_9_withdraw_is_enabled if (Environment.status_node_9_withdraw = enabled);\n  node_9_withdraw_is_executed if (Environment.status_node_9_withdraw = executed);\n  node_9_withdraw_is_authorized_by_M if (Environment.node_9_withdraw_authorized_by_part_M = true);\n  node_11_split_is_disabled if (Environment.status_node_11_split = disabled);\n  node_11_split_is_enabled if (Environment.status_node_11_split = enabled);\n  node_11_split_is_executed if (Environment.status_node_11_split = executed);\n  node_11_split_is_authorized_by_B if (Environment.node_11_split_authorized_by_part_B = true);\n  contract_funds_are_zero if (Environment.contract_funds = 0);\n  part_A_total_deposits_is_at_least_9 if (Environment.part_A_total_deposits &gt;= 9);\n  part_B_total_deposits_is_at_least_9 if (Environment.part_B_total_deposits &gt;= 9);\n  part_M_total_deposits_is_at_least_1 if (Environment.part_M_total_deposits &gt;= 1);\nend Evaluation\nInitStates\n  (((((((((((((((((((((((((((Environment.contract_funds = 10) and (Environment.part_A_total_deposits = 0)) and (Environment.part_M_total_deposits = 0)) and (Environment.part_B_total_deposits = 0)) and (Environment.contract_initialized = false)) and (Environment.node_0_withdraw_authorized_by_part_A = false)) and (Environment.status_node_0_withdraw = disabled)) and (Environment.node_1_withdraw_authorized_by_part_B = false)) and (Environment.status_node_1_withdraw = disabled)) and (Environment.status_node_2_withdraw = disabled)) and (Environment.node_3_withdraw_authorized_by_part_M = false)) and (Environment.status_node_3_withdraw = disabled)) and (Environment.node_4_withdraw_authorized_by_part_M = false)) and (Environment.status_node_4_withdraw = disabled)) and (Environment.node_6_split_authorized_by_part_A = false)) and (Environment.status_node_6_split = disabled)) and (Environment.status_node_7_withdraw = disabled)) and (Environment.node_8_withdraw_authorized_by_part_M = false)) and (Environment.status_node_8_withdraw = disabled)) and (Environment.node_9_withdraw_authorized_by_part_M = false)) and (Environment.status_node_9_withdraw = disabled)) and (Environment.node_11_split_authorized_by_part_B = false)) and (Environment.status_node_11_split = disabled)) and (Environment.last_action = unset)) and (Agent_M.dummy = false)) and (Agent_A.dummy = false)) and (Agent_B.dummy = false));\nend InitStates\nGroups\n  Participants = {Agent_A, Agent_B, Agent_M};\n  Env = {Environment};\n  ParticipantsAndEnv = {Agent_A, Agent_B, Agent_M, Environment};\n  Agent_M = {Agent_M};\n  Agent_A = {Agent_A};\n  Agent_B = {Agent_B};\n  Agent_A__Agent_M = {Agent_A, Agent_M};\n  Agent_B__Agent_M = {Agent_B, Agent_M};\n  Agent_A__Agent_B = {Agent_A, Agent_B};\nend Groups\nFairness\n  part_A_is_scheduled;\n  part_M_is_scheduled;\n  part_B_is_scheduled;\nend Fairness\nFormulae\n  (&lt;Agent_A&gt;F(contract_funds_are_zero));\n  (&lt;Agent_B&gt;F(contract_funds_are_zero));\n  (&lt;Agent_M&gt;F(contract_funds_are_zero));\n  (&lt;Agent_A__Agent_B&gt;F(contract_funds_are_zero));\n  (&lt;Agent_A__Agent_M&gt;F(contract_funds_are_zero));\n  (&lt;Agent_B__Agent_M&gt;F(contract_funds_are_zero));\n  (&lt;Agent_A&gt;F(part_A_total_deposits_is_at_least_9));\n  (&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_9));\n  (AG (((node_6_split_is_executed or node_11_split_is_executed)) -&gt; ((&lt;Agent_M&gt;F(part_M_total_deposits_is_at_least_1)))));\n  (AG (((((((node_6_split_is_executed or node_11_split_is_executed) and (!node_3_withdraw_is_authorized_by_M)) and (!node_4_withdraw_is_authorized_by_M)) and (!node_8_withdraw_is_authorized_by_M)) and (!node_9_withdraw_is_authorized_by_M))) -&gt; (((&lt;Agent_M&gt;F(part_A_total_deposits_is_at_least_9)) and (&lt;Agent_M&gt;F(part_B_total_deposits_is_at_least_9))))));\nend Formulae\n</code></pre> <p>By calling MCMAS with the command:</p> <pre><code>./mcmas -atlk 1  docs/03-escrow/contract.ispl\n</code></pre> <p>We get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0 \n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law. \n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./tests/bin/mcmas -atlk 1 docs/03-escrow/contract.ispl\n\ndocs/03-escrow/contract.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (&lt;Agent_A&gt;F contract_funds_are_zero), is FALSE in the model\n  Formula number 2: (&lt;Agent_B&gt;F contract_funds_are_zero), is FALSE in the model\n  Formula number 3: (&lt;Agent_M&gt;F contract_funds_are_zero), is FALSE in the model\n  Formula number 4: (&lt;Agent_A__Agent_B&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 5: (&lt;Agent_A__Agent_M&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 6: (&lt;Agent_B__Agent_M&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 7: (&lt;Agent_A&gt;F part_A_total_deposits_is_at_least_9), is FALSE in the model\n  Formula number 8: (&lt;Agent_B&gt;F part_B_total_deposits_is_at_least_9), is FALSE in the model\n  Formula number 9: (AG ((node_6_split_is_executed || node_11_split_is_executed) -&gt; (&lt;Agent_M&gt;F part_M_total_deposits_is_at_least_1))), is TRUE in the model\n  Formula number 10: (AG ((((((node_6_split_is_executed || node_11_split_is_executed) &amp;&amp; (! node_3_withdraw_is_authorized_by_M)) &amp;&amp; (! node_4_withdraw_is_authorized_by_M)) &amp;&amp; (! node_8_withdraw_is_authorized_by_M)) &amp;&amp; (! node_9_withdraw_is_authorized_by_M)) -&gt; ((&lt;Agent_M&gt;F part_A_total_deposits_is_at_least_9) &amp;&amp; (&lt;Agent_M&gt;F part_B_total_deposits_is_at_least_9)))), is TRUE in the model\ndone, 10 formulae successfully read and checked\nexecution time = 4.731\nnumber of reachable states = 4612\nBDD memory in use = 29765232\n</code></pre> In\u00a0[9]: Copied! <pre>bitml_zcb = \"\"\"\n#lang bitml\n\n(participant \"A\" \"00a\")\n(participant \"B\" \"00b\")\n(participant \"G\" \"00c\")\n\n\n(contract\n  (pre\n    (deposit \"A\" 9 \"txA@0\")\n    (vol-deposit \"B\" txb1 10 \"txB@0\")\n    (deposit \"G\" 10 \"txG@0\"))\n\n  (split\n    (9  -&gt; (withdraw \"B\"))\n    (10 -&gt; (choice\n      ; B pays the bond and G recovers his security deposit\n      (after 1 (put (txb1) (split (10 -&gt; (withdraw \"A\")) (10 -&gt; (withdraw \"G\")))))\n      ; guarantors pays the bond to A\n      (after 2 (withdraw \"A\"))\n    )))\n)\n\"\"\"\n</pre> bitml_zcb = \"\"\" #lang bitml  (participant \"A\" \"00a\") (participant \"B\" \"00b\") (participant \"G\" \"00c\")   (contract   (pre     (deposit \"A\" 9 \"txA@0\")     (vol-deposit \"B\" txb1 10 \"txB@0\")     (deposit \"G\" 10 \"txG@0\"))    (split     (9  -&gt; (withdraw \"B\"))     (10 -&gt; (choice       ; B pays the bond and G recovers his security deposit       (after 1 (put (txb1) (split (10 -&gt; (withdraw \"A\")) (10 -&gt; (withdraw \"G\")))))       ; guarantors pays the bond to A       (after 2 (withdraw \"A\"))     ))) ) \"\"\" <p>We will verify the following ${\\rm ATL}$ specifications:</p> <ul> <li>The contract is liquid from a single agent's perspective:</li> </ul> <p>$$ \\langle A \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>$$ \\langle B \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <p>$$ \\langle M \\rangle F (\\mathsf{contract\\_funds\\_are\\_zero}) $$</p> <ul> <li>we can check that $A$ and $G$ can cooperatively make sure $A$ gets its investment back, plus interests:</li> </ul> <p>$$  \\langle A, G\\rangle F (\\mathsf{part\\_A\\_total\\_deposits\\_is\\_10}) $$</p> <ul> <li>The bank can take at least $9$ bitcoin:</li> </ul> <p>$$ \\langle B\\rangle F (\\mathsf{part\\_B\\_total\\_deposits\\_is\\_at\\_least\\_9}) $$</p> <ul> <li>Neither $B$ nor $G$ can prevent $A$ from withdrawing funds:</li> </ul> <p>$$ \\quad \\lnot  \\langle B\\rangle G (\\lnot\\langle A \\rangle F \\mathsf{part\\_A\\_total\\_deposits\\_is\\_10})\\\\ \\wedge \\lnot \\langle G\\rangle G (\\lnot \\langle A\\rangle F \\mathsf{part\\_A\\_total\\_deposits\\_is\\_10}) $$</p> <p>The Python code to produce the ISPL is:</p> In\u00a0[10]: Copied! <pre># parse the contract\nparser = BitMLParser()\ncontract = parser(bitml_zcb)\n\nAGENT_A_AND_AGENT_G = \"Agent_A__Agent_G\"\n\n# &lt;Agent_A&gt;F(contract_funds_are_zero)\nAGENT_A_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_B&gt;F(contract_funds_are_zero)\nAGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO)\n# &lt;Agent_G&gt;F(contract_funds_are_zero)\nAGENT_G_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_G, CONTRACT_FUNDS_ARE_ZERO)\n\n# &lt;Agent_A, Agent_G&gt;F(part_A_total_deposits_is_10)\nAGENT_A_AND_AGENT_G_CAN_MAKE_A_GET_10 = DiamondEventuallyFormula(AGENT_A_AND_AGENT_G, PART_A_TOTAL_DEPOSITS_IS_10)\n# &lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_9)\nAGENT_B_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9)\n\nCANNOT_PREVENT_A_FROM_WITHDRAWING_FUNDS = AndFormula(\n    ~DiamondEventuallyFormula(AGENT_B, ~DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_10)),\n    ~DiamondEventuallyFormula(AGENT_B, ~DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_10)),\n)\n\nformulae = [\n    AGENT_A_CAN_ENFORCE_LIQUIDITY,\n    AGENT_B_CAN_ENFORCE_LIQUIDITY,\n    AGENT_G_CAN_ENFORCE_LIQUIDITY,\n    AGENT_A_AND_AGENT_G_CAN_MAKE_A_GET_10,\n    AGENT_B_CAN_GET_AT_LEAST_9\n    \n]\nevaluation_rules = [\n    CONTRACT_FUNDS_ARE_ZERO_ER,\n    PART_A_TOTAL_DEPOSITS_IS_10_ER,\n    PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER,\n]\ncompiler = Compiler(\n    contract, formulae, evaluation_rules=evaluation_rules\n)\ninterpreted_system = compiler.compile()\ninterpreted_system_str = interpreted_system_to_string(interpreted_system)\n_ = Path(\"04-zero-coupon-bond/contract.ispl\").write_text(interpreted_system_str)\n</pre> # parse the contract parser = BitMLParser() contract = parser(bitml_zcb)  AGENT_A_AND_AGENT_G = \"Agent_A__Agent_G\"  # F(contract_funds_are_zero) AGENT_A_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_A, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_B_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_B, CONTRACT_FUNDS_ARE_ZERO) # F(contract_funds_are_zero) AGENT_G_CAN_ENFORCE_LIQUIDITY = DiamondEventuallyFormula(AGENT_G, CONTRACT_FUNDS_ARE_ZERO)  # F(part_A_total_deposits_is_10) AGENT_A_AND_AGENT_G_CAN_MAKE_A_GET_10 = DiamondEventuallyFormula(AGENT_A_AND_AGENT_G, PART_A_TOTAL_DEPOSITS_IS_10) # F(part_B_total_deposits_is_at_least_9) AGENT_B_CAN_GET_AT_LEAST_9 = DiamondEventuallyFormula(AGENT_B, PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9)  CANNOT_PREVENT_A_FROM_WITHDRAWING_FUNDS = AndFormula(     ~DiamondEventuallyFormula(AGENT_B, ~DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_10)),     ~DiamondEventuallyFormula(AGENT_B, ~DiamondEventuallyFormula(AGENT_A, PART_A_TOTAL_DEPOSITS_IS_10)), )  formulae = [     AGENT_A_CAN_ENFORCE_LIQUIDITY,     AGENT_B_CAN_ENFORCE_LIQUIDITY,     AGENT_G_CAN_ENFORCE_LIQUIDITY,     AGENT_A_AND_AGENT_G_CAN_MAKE_A_GET_10,     AGENT_B_CAN_GET_AT_LEAST_9      ] evaluation_rules = [     CONTRACT_FUNDS_ARE_ZERO_ER,     PART_A_TOTAL_DEPOSITS_IS_10_ER,     PART_B_TOTAL_DEPOSITS_IS_AT_LEAST_9_ER, ] compiler = Compiler(     contract, formulae, evaluation_rules=evaluation_rules ) interpreted_system = compiler.compile() interpreted_system_str = interpreted_system_to_string(interpreted_system) _ = Path(\"04-zero-coupon-bond/contract.ispl\").write_text(interpreted_system_str) <p>The output file <code>04-zero-coupon-bond/contract.ispl</code> is pasted below:</p> <pre><code>Semantics=SingleAssignment;\nAgent Environment\n  Obsvars:\n    time: 0..2;\n    contract_funds: 0..29;\n    part_G_total_deposits: 0..29;\n    part_A_total_deposits: 0..29;\n    part_B_total_deposits: 0..29;\n    spent_deposit_txb1: boolean;\n    contract_initialized: boolean;\n    status_node_0_withdraw: {disabled, enabled, executed};\n    status_node_1_withdraw: {disabled, enabled, executed};\n    status_node_2_withdraw: {disabled, enabled, executed};\n    status_node_3_split: {disabled, enabled, executed};\n    status_node_4_put: {disabled, enabled, executed};\n    status_node_5_withdraw: {disabled, enabled, executed};\n    status_node_7_split: {disabled, enabled, executed};\n  end Obsvars\n  Vars:\n    part_G_is_done: boolean;\n    part_A_is_done: boolean;\n    part_B_is_done: boolean;\n    last_action: {action_delay, action_schedule_part_A, action_schedule_part_B, action_schedule_part_G, unset};\n  end Vars\n\n  Actions = {delay, schedule_part_A, schedule_part_B, schedule_part_G};\n  Protocol:\n    (part_G_is_done = false): {schedule_part_G};\n    (part_A_is_done = false): {schedule_part_A};\n    (part_B_is_done = false): {schedule_part_B};\n    Other: {delay};\n  end Protocol\n  Evolution:\n    part_G_is_done = false if ((Action = delay) and (((part_G_is_done = true) and (part_A_is_done = true)) and (part_B_is_done = true)));\n    part_A_is_done = false if ((Action = delay) and (((part_G_is_done = true) and (part_A_is_done = true)) and (part_B_is_done = true)));\n    part_B_is_done = false if ((Action = delay) and (((part_G_is_done = true) and (part_A_is_done = true)) and (part_B_is_done = true)));\n    part_G_is_done = true if (((Action = schedule_part_G) and (Agent_G.Action = nop)) and (part_G_is_done = false));\n    part_A_is_done = true if (((Action = schedule_part_A) and (Agent_A.Action = nop)) and (part_A_is_done = false));\n    part_B_is_done = true if (((Action = schedule_part_B) and (Agent_B.Action = nop)) and (part_B_is_done = false));\n    time = (time + 1) if (((Action = delay) and (((part_G_is_done = true) and (part_A_is_done = true)) and (part_B_is_done = true))) and (time &lt; 2));\n    contract_initialized = true if ((contract_initialized = false) and ((((Action = schedule_part_G) and (Agent_G.Action = initialize_contract)) or ((Action = schedule_part_A) and (Agent_A.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))));\n    contract_funds = (contract_funds - 9) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_0_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    part_B_total_deposits = (part_B_total_deposits + 9) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_0_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_0_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_0_withdraw)));\n    status_node_0_withdraw = executed if ((((Agent_G.Action = exec_node_0_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_0_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_0_withdraw) and (Action = schedule_part_B)));\n    status_node_0_withdraw = enabled if (((status_node_7_split = executed) or ((((Agent_G.Action = exec_node_7_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_7_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_7_split) and (Action = schedule_part_B)))) and (status_node_0_withdraw = disabled));\n    contract_funds = (contract_funds - 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_1_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_1_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_1_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_1_withdraw)));\n    status_node_1_withdraw = executed if ((((Agent_G.Action = exec_node_1_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_1_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_1_withdraw) and (Action = schedule_part_B)));\n    status_node_1_withdraw = enabled if (((status_node_3_split = executed) or ((((Agent_G.Action = exec_node_3_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_3_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_3_split) and (Action = schedule_part_B)))) and (status_node_1_withdraw = disabled));\n    contract_funds = (contract_funds - 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_2_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    part_G_total_deposits = (part_G_total_deposits + 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_2_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_2_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_2_withdraw)));\n    status_node_2_withdraw = executed if ((((Agent_G.Action = exec_node_2_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_2_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_2_withdraw) and (Action = schedule_part_B)));\n    status_node_2_withdraw = enabled if (((status_node_3_split = executed) or ((((Agent_G.Action = exec_node_3_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_3_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_3_split) and (Action = schedule_part_B)))) and (status_node_2_withdraw = disabled));\n    status_node_3_split = executed if ((((Agent_G.Action = exec_node_3_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_3_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_3_split) and (Action = schedule_part_B)));\n    status_node_3_split = enabled if (((status_node_4_put = executed) or ((((Agent_G.Action = exec_node_4_put) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_4_put) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_4_put) and (Action = schedule_part_B)))) and (status_node_3_split = disabled));\n    status_node_4_put = executed if ((((Agent_G.Action = exec_node_4_put) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_4_put) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_4_put) and (Action = schedule_part_B)));\n    contract_funds = (contract_funds + 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_4_put)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_put))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_put)));\n    spent_deposit_txb1 = true if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_4_put)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_put))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_put)));\n    part_B_total_deposits = (part_B_total_deposits - 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_4_put)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_4_put))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_4_put)));\n    status_node_4_put = enabled if ((((((status_node_7_split = executed) or ((((Agent_G.Action = exec_node_7_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_7_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_7_split) and (Action = schedule_part_B)))) and (status_node_4_put = disabled)) and (spent_deposit_txb1 = false)) and ((time &gt;= 1) or ((time = 0) and (Action = delay)))) and (!((status_node_5_withdraw = executed) or ((((Agent_G.Action = exec_node_5_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_5_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_5_withdraw) and (Action = schedule_part_B))))));\n    status_node_4_put = disabled if ((status_node_5_withdraw = executed) or ((((Agent_G.Action = exec_node_5_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_5_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_5_withdraw) and (Action = schedule_part_B))));\n    contract_funds = (contract_funds - 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_5_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_5_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_5_withdraw)));\n    part_A_total_deposits = (part_A_total_deposits + 10) if ((((Action = schedule_part_G) and (Agent_G.Action = exec_node_5_withdraw)) or ((Action = schedule_part_A) and (Agent_A.Action = exec_node_5_withdraw))) or ((Action = schedule_part_B) and (Agent_B.Action = exec_node_5_withdraw)));\n    status_node_5_withdraw = executed if ((((Agent_G.Action = exec_node_5_withdraw) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_5_withdraw) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_5_withdraw) and (Action = schedule_part_B)));\n    status_node_5_withdraw = enabled if (((((status_node_7_split = executed) or ((((Agent_G.Action = exec_node_7_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_7_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_7_split) and (Action = schedule_part_B)))) and (status_node_5_withdraw = disabled)) and ((time &gt;= 2) or ((time = 1) and (Action = delay)))) and (!((status_node_4_put = executed) or ((((Agent_G.Action = exec_node_4_put) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_4_put) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_4_put) and (Action = schedule_part_B))))));\n    status_node_5_withdraw = disabled if ((status_node_4_put = executed) or ((((Agent_G.Action = exec_node_4_put) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_4_put) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_4_put) and (Action = schedule_part_B))));\n    status_node_7_split = executed if ((((Agent_G.Action = exec_node_7_split) and (Action = schedule_part_G)) or ((Agent_A.Action = exec_node_7_split) and (Action = schedule_part_A))) or ((Agent_B.Action = exec_node_7_split) and (Action = schedule_part_B)));\n    status_node_7_split = enabled if ((((((Action = schedule_part_G) and (Agent_G.Action = initialize_contract)) or ((Action = schedule_part_A) and (Agent_A.Action = initialize_contract))) or ((Action = schedule_part_B) and (Agent_B.Action = initialize_contract))) or (contract_initialized = true)) and (status_node_7_split = disabled));\n    last_action = action_schedule_part_B if (Action = schedule_part_B);\n    last_action = action_schedule_part_A if (Action = schedule_part_A);\n    last_action = action_schedule_part_G if (Action = schedule_part_G);\n    last_action = action_delay if (Action = delay);\n  end Evolution\nend Agent\n\nAgent Agent_G\n  Lobsvars = {part_G_is_done};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_split, exec_node_4_put, exec_node_5_withdraw, exec_node_7_split, initialize_contract, nop};\n  Protocol:\n    ((Environment.contract_initialized = false) and (Environment.part_G_is_done = false)): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_G_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_G_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_withdraw = enabled) and (Environment.part_G_is_done = false)): {exec_node_2_withdraw, nop};\n    ((Environment.status_node_3_split = enabled) and (Environment.part_G_is_done = false)): {exec_node_3_split, nop};\n    ((Environment.status_node_4_put = enabled) and (Environment.part_G_is_done = false)): {exec_node_4_put, nop};\n    ((Environment.status_node_5_withdraw = enabled) and (Environment.part_G_is_done = false)): {exec_node_5_withdraw, nop};\n    ((Environment.status_node_7_split = enabled) and (Environment.part_G_is_done = false)): {exec_node_7_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nAgent Agent_A\n  Lobsvars = {part_A_is_done};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_split, exec_node_4_put, exec_node_5_withdraw, exec_node_7_split, initialize_contract, nop};\n  Protocol:\n    ((Environment.contract_initialized = false) and (Environment.part_A_is_done = false)): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_2_withdraw, nop};\n    ((Environment.status_node_3_split = enabled) and (Environment.part_A_is_done = false)): {exec_node_3_split, nop};\n    ((Environment.status_node_4_put = enabled) and (Environment.part_A_is_done = false)): {exec_node_4_put, nop};\n    ((Environment.status_node_5_withdraw = enabled) and (Environment.part_A_is_done = false)): {exec_node_5_withdraw, nop};\n    ((Environment.status_node_7_split = enabled) and (Environment.part_A_is_done = false)): {exec_node_7_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nAgent Agent_B\n  Lobsvars = {part_B_is_done};\n  Vars:\n    dummy: boolean;\n  end Vars\n\n  Actions = {exec_node_0_withdraw, exec_node_1_withdraw, exec_node_2_withdraw, exec_node_3_split, exec_node_4_put, exec_node_5_withdraw, exec_node_7_split, initialize_contract, nop};\n  Protocol:\n    ((Environment.contract_initialized = false) and (Environment.part_B_is_done = false)): {initialize_contract, nop};\n    ((Environment.status_node_0_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_0_withdraw, nop};\n    ((Environment.status_node_1_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_1_withdraw, nop};\n    ((Environment.status_node_2_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_2_withdraw, nop};\n    ((Environment.status_node_3_split = enabled) and (Environment.part_B_is_done = false)): {exec_node_3_split, nop};\n    ((Environment.status_node_4_put = enabled) and (Environment.part_B_is_done = false)): {exec_node_4_put, nop};\n    ((Environment.status_node_5_withdraw = enabled) and (Environment.part_B_is_done = false)): {exec_node_5_withdraw, nop};\n    ((Environment.status_node_7_split = enabled) and (Environment.part_B_is_done = false)): {exec_node_7_split, nop};\n    Other: {nop};\n  end Protocol\n  Evolution:\n    dummy = false if (dummy = false);\n  end Evolution\nend Agent\nEvaluation\n  part_G_is_scheduled if (Environment.last_action = action_schedule_part_G);\n  part_A_is_scheduled if (Environment.last_action = action_schedule_part_A);\n  part_B_is_scheduled if (Environment.last_action = action_schedule_part_B);\n  time_progresses_forever if ((Environment.time = 2) or (Environment.last_action = action_delay));\n  time_reaches_maximum if (Environment.time = 2);\n  timeout_1_has_expired if (Environment.time &gt;= 1);\n  timeout_2_has_expired if (Environment.time &gt;= 2);\n  part_G_is_done if (Environment.part_G_is_done = true);\n  part_A_is_done if (Environment.part_A_is_done = true);\n  part_B_is_done if (Environment.part_B_is_done = true);\n  contract_is_initialized if (Environment.contract_initialized = true);\n  node_0_withdraw_is_disabled if (Environment.status_node_0_withdraw = disabled);\n  node_0_withdraw_is_enabled if (Environment.status_node_0_withdraw = enabled);\n  node_0_withdraw_is_executed if (Environment.status_node_0_withdraw = executed);\n  node_1_withdraw_is_disabled if (Environment.status_node_1_withdraw = disabled);\n  node_1_withdraw_is_enabled if (Environment.status_node_1_withdraw = enabled);\n  node_1_withdraw_is_executed if (Environment.status_node_1_withdraw = executed);\n  node_2_withdraw_is_disabled if (Environment.status_node_2_withdraw = disabled);\n  node_2_withdraw_is_enabled if (Environment.status_node_2_withdraw = enabled);\n  node_2_withdraw_is_executed if (Environment.status_node_2_withdraw = executed);\n  node_3_split_is_disabled if (Environment.status_node_3_split = disabled);\n  node_3_split_is_enabled if (Environment.status_node_3_split = enabled);\n  node_3_split_is_executed if (Environment.status_node_3_split = executed);\n  node_4_put_is_disabled if (Environment.status_node_4_put = disabled);\n  node_4_put_is_enabled if (Environment.status_node_4_put = enabled);\n  node_4_put_is_executed if (Environment.status_node_4_put = executed);\n  node_5_withdraw_is_disabled if (Environment.status_node_5_withdraw = disabled);\n  node_5_withdraw_is_enabled if (Environment.status_node_5_withdraw = enabled);\n  node_5_withdraw_is_executed if (Environment.status_node_5_withdraw = executed);\n  node_7_split_is_disabled if (Environment.status_node_7_split = disabled);\n  node_7_split_is_enabled if (Environment.status_node_7_split = enabled);\n  node_7_split_is_executed if (Environment.status_node_7_split = executed);\n  contract_funds_are_zero if (Environment.contract_funds = 0);\n  part_A_total_deposits_is_10 if (Environment.part_A_total_deposits &gt;= 10);\n  part_B_total_deposits_is_at_least_9 if (Environment.part_B_total_deposits &gt;= 9);\nend Evaluation\nInitStates\n  (((((((((((((((((((((Environment.time = 0) and (Environment.part_G_is_done = false)) and (Environment.part_A_is_done = false)) and (Environment.part_B_is_done = false)) and (Environment.contract_funds = 19)) and (Environment.part_G_total_deposits = 0)) and (Environment.part_A_total_deposits = 0)) and (Environment.part_B_total_deposits = 10)) and (Environment.spent_deposit_txb1 = false)) and (Environment.contract_initialized = false)) and (Environment.status_node_0_withdraw = disabled)) and (Environment.status_node_1_withdraw = disabled)) and (Environment.status_node_2_withdraw = disabled)) and (Environment.status_node_3_split = disabled)) and (Environment.status_node_4_put = disabled)) and (Environment.status_node_5_withdraw = disabled)) and (Environment.status_node_7_split = disabled)) and (Environment.last_action = unset)) and (Agent_G.dummy = false)) and (Agent_A.dummy = false)) and (Agent_B.dummy = false));\nend InitStates\nGroups\n  Participants = {Agent_A, Agent_B, Agent_G};\n  Env = {Environment};\n  ParticipantsAndEnv = {Agent_A, Agent_B, Agent_G, Environment};\n  Agent_G = {Agent_G};\n  Agent_A = {Agent_A};\n  Agent_B = {Agent_B};\n  Agent_A__Agent_G = {Agent_A, Agent_G};\n  Agent_B__Agent_G = {Agent_B, Agent_G};\n  Agent_A__Agent_B = {Agent_A, Agent_B};\nend Groups\nFairness\n  part_G_is_scheduled;\n  part_A_is_scheduled;\n  part_B_is_scheduled;\n  time_progresses_forever;\nend Fairness\nFormulae\n  (&lt;Agent_A&gt;F(contract_funds_are_zero));\n  (&lt;Agent_B&gt;F(contract_funds_are_zero));\n  (&lt;Agent_G&gt;F(contract_funds_are_zero));\n  (&lt;Agent_A__Agent_G&gt;F(part_A_total_deposits_is_10));\n  (&lt;Agent_B&gt;F(part_B_total_deposits_is_at_least_9));\nend Formulae\n</code></pre> <p>By calling MCMAS with the command:</p> <pre><code>./mcmas -atlk 1  docs/04-zero-coupon-bond/contract.ispl\n</code></pre> <p>We get the following output:</p> <pre><code>************************************************************************\n                       MCMAS v1.3.0 \n\n This software comes with ABSOLUTELY NO WARRANTY, to the extent\n permitted by applicable law. \n\n Please check http://vas.doc.ic.ac.uk/tools/mcmas/ for the latest release.\n Please send any feedback to &lt;mcmas@imperial.ac.uk&gt;\n************************************************************************\n\nCommand line: ./tests/bin/mcmas -atlk 1 docs/04-zero-coupon-bond/contract.ispl\n\ndocs/04-zero-coupon-bond/contract.ispl has been parsed successfully.\nGlobal syntax checking...\n1\n1\n1\nDone\nEncoding BDD parameters...\nBuilding partial transition relation...\nBuilding BDD for initial states...\nBuilding reachable state space...\nChecking formulae...\nBuilding set of fair states...\nVerifying properties...\n  Formula number 1: (&lt;Agent_A&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 2: (&lt;Agent_B&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 3: (&lt;Agent_G&gt;F contract_funds_are_zero), is TRUE in the model\n  Formula number 4: (&lt;Agent_A__Agent_G&gt;F part_A_total_deposits_is_10), is TRUE in the model\n  Formula number 5: (&lt;Agent_B&gt;F part_B_total_deposits_is_at_least_9), is TRUE in the model\ndone, 5 formulae successfully read and checked\nexecution time = 4.988\nnumber of reachable states = 1129\nBDD memory in use = 28123696\n</code></pre>"},{"location":"tutorial/#more-contracts","title":"More contracts\u00b6","text":""},{"location":"tutorial/#propositions-and-evaluation-rules","title":"Propositions and Evaluation Rules\u00b6","text":"<p>In this section, we define the propositions and their evaluation rules, which define the alphabet to express ATL specifications.</p>"},{"location":"tutorial/#timed-commitment","title":"Timed Commitment\u00b6","text":"<p>In this section, we will verify a BitML formalization of the timed commitment protocol.</p> <p>First, we need to compile the BitML contract into an ISPL file.</p> <p>The BitML contract is the following:</p>"},{"location":"tutorial/#mutual-timed-commitment","title":"Mutual Timed Commitment\u00b6","text":"<p>In this section, we will verify a BitML formalization of the mutual timed commitment protocol.</p> <p>The BitML contract is the following:</p>"},{"location":"tutorial/#escrow","title":"Escrow\u00b6","text":"<p>In this section, we will verify a BitML formalization of an escrow contract.</p> <p>The BitML contract is the following:</p>"},{"location":"tutorial/#zero-coupon-bond","title":"Zero-Coupon Bond\u00b6","text":"<p>In this section, we will verify a BitML formalization of a zero-coupon bond contract.</p> <p>The BitML contract is the following:</p>"}]}